
# Файл ".pre-commit-config.yaml":

repos:
  - repo: https://github.com/pre-commit/mirrors-isort
    rev: v5.10.1
    hooks:
      - id: isort
  - repo: https://github.com/psf/black
    rev: 25.1.0
    hooks:
      - id: black



# Файл "pyproject.toml":

[tool.black]
line-length = 120

[tool.isort]
multi_line_output = 3
include_trailing_comma = true



# Файл "app\test.ipynb":

{
 "cells": [
  {
   "cell_type": "markdown",
   "source": [
    "# Real Time Animation"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Import libs and modules"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "outputs": [],
   "source": [
    "import os\n",
    "import cv2\n",
    "import torch\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from skimage.transform import resize\n",
    "\n",
    "from src.ml.services.animation import AnimationService\n",
    "from src.ml.services.model import ModelService\n",
    "from src.ml.services.video_animation import VideoAnimationService"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:06.354464400Z",
     "start_time": "2025-05-18T08:28:06.319894100Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Configuration"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "outputs": [],
   "source": [
    "RELATIVE = True\n",
    "ADAPT_MOVEMENT_SCALE = True\n",
    "USE_CPU = True\n",
    "VIDEO_CODEC = 'MJPG'\n",
    "SOURCE_IMAGE_NAME = './data/input/nick.jpg'\n",
    "RESULT_VIDEO_DIR = './data/output'\n",
    "RESULT_VIDEO_NAME = './data/output/real_time_test.avi'\n",
    "MODEL_CONFIG_PATH = './data/configs/vox-256.yaml'\n",
    "MODEL_CHECKPOINT_PATH = './data/checkpoints/vox-cpk.pth.tar'\n",
    "WINDOW_NAME = 'Real Time Animation'"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:07.905789700Z",
     "start_time": "2025-05-18T08:28:07.887035700Z"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "os.makedirs('./data/output', exist_ok=True)"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:08.674426200Z",
     "start_time": "2025-05-18T08:28:08.644309100Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Prepare source image"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "outputs": [],
   "source": [
    "source_image = cv2.imread(SOURCE_IMAGE_NAME)\n",
    "source_image = cv2.cvtColor(source_image, cv2.COLOR_BGR2RGB)\n",
    "source_image = resize(source_image, (256, 256))[..., :3]"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:10.879897600Z",
     "start_time": "2025-05-18T08:28:10.089322900Z"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "outputs": [
    {
     "data": {
      "text/plain": "<Figure size 640x480 with 1 Axes>",
      "image/png": "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"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.imshow(source_image)\n",
    "plt.axis('off')\n",
    "plt.show()"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:12.167218500Z",
     "start_time": "2025-05-18T08:28:11.970193400Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Prepare model"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "OcclusionAwareGenerator(\n",
      "  (dense_motion_network): DenseMotionNetwork(\n",
      "    (hourglass): Hourglass(\n",
      "      (encoder): Encoder(\n",
      "        (down_blocks): ModuleList(\n",
      "          (0): DownBlock2d(\n",
      "            (conv): Conv2d(44, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "          )\n",
      "          (1): DownBlock2d(\n",
      "            (conv): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "          )\n",
      "          (2): DownBlock2d(\n",
      "            (conv): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "          )\n",
      "          (3): DownBlock2d(\n",
      "            (conv): Conv2d(512, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "          )\n",
      "          (4): DownBlock2d(\n",
      "            (conv): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "          )\n",
      "        )\n",
      "      )\n",
      "      (decoder): Decoder(\n",
      "        (up_blocks): ModuleList(\n",
      "          (0): UpBlock2d(\n",
      "            (conv): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "          (1): UpBlock2d(\n",
      "            (conv): Conv2d(2048, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "          (2): UpBlock2d(\n",
      "            (conv): Conv2d(1024, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "          (3): UpBlock2d(\n",
      "            (conv): Conv2d(512, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "          (4): UpBlock2d(\n",
      "            (conv): Conv2d(256, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "            (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "      )\n",
      "    )\n",
      "    (mask): Conv2d(108, 11, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n",
      "    (occlusion): Conv2d(108, 1, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n",
      "    (down): AntiAliasInterpolation2d()\n",
      "  )\n",
      "  (first): SameBlock2d(\n",
      "    (conv): Conv2d(3, 64, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n",
      "    (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "  )\n",
      "  (down_blocks): ModuleList(\n",
      "    (0): DownBlock2d(\n",
      "      (conv): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "    )\n",
      "    (1): DownBlock2d(\n",
      "      (conv): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "    )\n",
      "  )\n",
      "  (up_blocks): ModuleList(\n",
      "    (0): UpBlock2d(\n",
      "      (conv): Conv2d(256, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (1): UpBlock2d(\n",
      "      (conv): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (bottleneck): Sequential(\n",
      "    (r0): ResBlock2d(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (r1): ResBlock2d(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (r2): ResBlock2d(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (r3): ResBlock2d(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (r4): ResBlock2d(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (r5): ResBlock2d(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "      (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (final): Conv2d(64, 3, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n",
      ")\n",
      "MultiScaleDiscriminator(\n",
      "  (discs): ModuleDict(\n",
      "    (1): Discriminator(\n",
      "      (down_blocks): ModuleList(\n",
      "        (0): DownBlock2d(\n",
      "          (conv): Conv2d(3, 64, kernel_size=(4, 4), stride=(1, 1))\n",
      "          (norm): Identity()\n",
      "          (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)\n",
      "        )\n",
      "        (1): DownBlock2d(\n",
      "          (conv): Conv2d(64, 128, kernel_size=(4, 4), stride=(1, 1))\n",
      "          (norm): InstanceNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)\n",
      "          (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)\n",
      "        )\n",
      "        (2): DownBlock2d(\n",
      "          (conv): Conv2d(128, 256, kernel_size=(4, 4), stride=(1, 1))\n",
      "          (norm): InstanceNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)\n",
      "          (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)\n",
      "        )\n",
      "        (3): DownBlock2d(\n",
      "          (conv): Conv2d(256, 512, kernel_size=(4, 4), stride=(1, 1))\n",
      "          (norm): InstanceNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)\n",
      "          (pool): Identity()\n",
      "        )\n",
      "      )\n",
      "      (conv): Conv2d(512, 1, kernel_size=(1, 1), stride=(1, 1))\n",
      "    )\n",
      "  )\n",
      ")\n",
      "KPDetector(\n",
      "  (predictor): Hourglass(\n",
      "    (encoder): Encoder(\n",
      "      (down_blocks): ModuleList(\n",
      "        (0): DownBlock2d(\n",
      "          (conv): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "        )\n",
      "        (1): DownBlock2d(\n",
      "          (conv): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "        )\n",
      "        (2): DownBlock2d(\n",
      "          (conv): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "        )\n",
      "        (3): DownBlock2d(\n",
      "          (conv): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "        )\n",
      "        (4): DownBlock2d(\n",
      "          (conv): Conv2d(512, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n",
      "        )\n",
      "      )\n",
      "    )\n",
      "    (decoder): Decoder(\n",
      "      (up_blocks): ModuleList(\n",
      "        (0): UpBlock2d(\n",
      "          (conv): Conv2d(1024, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (1): UpBlock2d(\n",
      "          (conv): Conv2d(1024, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (2): UpBlock2d(\n",
      "          (conv): Conv2d(512, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (3): UpBlock2d(\n",
      "          (conv): Conv2d(256, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (4): UpBlock2d(\n",
      "          (conv): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n",
      "          (norm): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "      )\n",
      "    )\n",
      "  )\n",
      "  (kp): Conv2d(35, 10, kernel_size=(7, 7), stride=(1, 1))\n",
      "  (jacobian): Conv2d(35, 40, kernel_size=(7, 7), stride=(1, 1))\n",
      "  (down): AntiAliasInterpolation2d()\n",
      ")\n"
     ]
    },
    {
     "data": {
      "text/plain": "(OcclusionAwareGenerator(\n   (dense_motion_network): DenseMotionNetwork(\n     (hourglass): Hourglass(\n       (encoder): Encoder(\n         (down_blocks): ModuleList(\n           (0): DownBlock2d(\n             (conv): Conv2d(44, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n             (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n           )\n           (1): DownBlock2d(\n             (conv): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n             (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n           )\n           (2): DownBlock2d(\n             (conv): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n             (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n           )\n           (3): DownBlock2d(\n             (conv): Conv2d(512, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n             (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n           )\n           (4): DownBlock2d(\n             (conv): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n             (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n           )\n         )\n       )\n       (decoder): Decoder(\n         (up_blocks): ModuleList(\n           (0): UpBlock2d(\n             (conv): Conv2d(1024, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           )\n           (1): UpBlock2d(\n             (conv): Conv2d(2048, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           )\n           (2): UpBlock2d(\n             (conv): Conv2d(1024, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           )\n           (3): UpBlock2d(\n             (conv): Conv2d(512, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           )\n           (4): UpBlock2d(\n             (conv): Conv2d(256, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n             (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           )\n         )\n       )\n     )\n     (mask): Conv2d(108, 11, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n     (occlusion): Conv2d(108, 1, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n     (down): AntiAliasInterpolation2d()\n   )\n   (first): SameBlock2d(\n     (conv): Conv2d(3, 64, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n     (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n   )\n   (down_blocks): ModuleList(\n     (0): DownBlock2d(\n       (conv): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n     )\n     (1): DownBlock2d(\n       (conv): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n     )\n   )\n   (up_blocks): ModuleList(\n     (0): UpBlock2d(\n       (conv): Conv2d(256, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n     (1): UpBlock2d(\n       (conv): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n   )\n   (bottleneck): Sequential(\n     (r0): ResBlock2d(\n       (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n     (r1): ResBlock2d(\n       (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n     (r2): ResBlock2d(\n       (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n     (r3): ResBlock2d(\n       (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n     (r4): ResBlock2d(\n       (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n     (r5): ResBlock2d(\n       (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n       (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n       (norm2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n     )\n   )\n   (final): Conv2d(64, 3, kernel_size=(7, 7), stride=(1, 1), padding=(3, 3))\n ),\n MultiScaleDiscriminator(\n   (discs): ModuleDict(\n     (1): Discriminator(\n       (down_blocks): ModuleList(\n         (0): DownBlock2d(\n           (conv): Conv2d(3, 64, kernel_size=(4, 4), stride=(1, 1))\n           (norm): Identity()\n           (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)\n         )\n         (1): DownBlock2d(\n           (conv): Conv2d(64, 128, kernel_size=(4, 4), stride=(1, 1))\n           (norm): InstanceNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)\n           (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)\n         )\n         (2): DownBlock2d(\n           (conv): Conv2d(128, 256, kernel_size=(4, 4), stride=(1, 1))\n           (norm): InstanceNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)\n           (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)\n         )\n         (3): DownBlock2d(\n           (conv): Conv2d(256, 512, kernel_size=(4, 4), stride=(1, 1))\n           (norm): InstanceNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=False)\n           (pool): Identity()\n         )\n       )\n       (conv): Conv2d(512, 1, kernel_size=(1, 1), stride=(1, 1))\n     )\n   )\n ),\n KPDetector(\n   (predictor): Hourglass(\n     (encoder): Encoder(\n       (down_blocks): ModuleList(\n         (0): DownBlock2d(\n           (conv): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n         )\n         (1): DownBlock2d(\n           (conv): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n         )\n         (2): DownBlock2d(\n           (conv): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n         )\n         (3): DownBlock2d(\n           (conv): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n         )\n         (4): DownBlock2d(\n           (conv): Conv2d(512, 1024, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n           (pool): AvgPool2d(kernel_size=(2, 2), stride=(2, 2), padding=0)\n         )\n       )\n     )\n     (decoder): Decoder(\n       (up_blocks): ModuleList(\n         (0): UpBlock2d(\n           (conv): Conv2d(1024, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n         )\n         (1): UpBlock2d(\n           (conv): Conv2d(1024, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n         )\n         (2): UpBlock2d(\n           (conv): Conv2d(512, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n         )\n         (3): UpBlock2d(\n           (conv): Conv2d(256, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n         )\n         (4): UpBlock2d(\n           (conv): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n           (norm): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n         )\n       )\n     )\n   )\n   (kp): Conv2d(35, 10, kernel_size=(7, 7), stride=(1, 1))\n   (jacobian): Conv2d(35, 40, kernel_size=(7, 7), stride=(1, 1))\n   (down): AntiAliasInterpolation2d()\n ))"
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "model_service = ModelService(\n",
    "    config_path=MODEL_CONFIG_PATH,\n",
    "    checkpoint_path=MODEL_CHECKPOINT_PATH,\n",
    "    cpu=USE_CPU,\n",
    "    verbose=True,\n",
    ")\n",
    "\n",
    "model_service.init_training_models([])"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:32:47.275492900Z",
     "start_time": "2025-05-18T08:32:45.829557700Z"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "outputs": [],
   "source": [
    "generator, kp_detector = model_service.load_eval_models()"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:20.159296400Z",
     "start_time": "2025-05-18T08:28:13.923907600Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Additional functions"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "outputs": [],
   "source": [
    "def preprocess_frame(frame, crop_box, target_size=(256, 256)):\n",
    "    x, y, w, h = crop_box\n",
    "    frame = cv2.flip(frame, 1)\n",
    "    frame = frame[y:y+h, x:x+w]\n",
    "    frame = resize(frame, target_size)[..., :3]\n",
    "    return frame"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:21.438568700Z",
     "start_time": "2025-05-18T08:28:21.382429600Z"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "outputs": [],
   "source": [
    "def to_tensor(img, use_cpu=False):\n",
    "    tensor = torch.tensor(img[np.newaxis].astype(np.float32)).permute(0, 3, 1, 2)\n",
    "    return tensor if use_cpu else tensor.cuda()"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:22.646106200Z",
     "start_time": "2025-05-18T08:28:22.619388200Z"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "outputs": [],
   "source": [
    "def generate_frame(source, kp_source, frame_tensor, kp_initial, generator, kp_detector):\n",
    "    kp_driving = kp_detector(frame_tensor)\n",
    "    kp_norm = AnimationService.normalize_kp(\n",
    "        kp_source=kp_source,\n",
    "        kp_driving=kp_driving,\n",
    "        kp_driving_initial=kp_initial,\n",
    "        use_relative_movement=RELATIVE,\n",
    "        use_relative_jacobian=RELATIVE,\n",
    "        adapt_movement_scale=ADAPT_MOVEMENT_SCALE,\n",
    "    )\n",
    "    out = generator(source, kp_source=kp_source, kp_driving=kp_norm)\n",
    "    prediction = out['prediction'][0].data.cpu().permute(1, 2, 0).numpy()\n",
    "    \n",
    "    from torchviz import make_dot\n",
    "    prediction_tensor = out['prediction'][0]\n",
    "    make_dot(prediction_tensor, params=dict(generator.named_parameters())).render(\"generator\", format=\"png\")\n",
    "    make_dot(kp_driving['value'], params=dict(kp_detector.named_parameters())).render(\"kp_detector\", format=\"png\")\n",
    "    \n",
    "    return prediction"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:29:52.040658Z",
     "start_time": "2025-05-18T08:29:52.007471100Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Prepare real time animation"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "outputs": [],
   "source": [
    "cap = cv2.VideoCapture(0)\n",
    "fourcc = cv2.VideoWriter_fourcc(*VIDEO_CODEC)\n",
    "out_video = cv2.VideoWriter(RESULT_VIDEO_NAME, fourcc, 12, (256 * 3, 256), True)\n",
    "\n",
    "source_rgb = cv2.cvtColor(source_image.astype('float32'), cv2.COLOR_BGR2RGB)\n",
    "source_tensor = to_tensor(source_image, use_cpu=USE_CPU)"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:28:30.426836600Z",
     "start_time": "2025-05-18T08:28:24.285233Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "## Start real time animation"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "with torch.no_grad():\n",
    "    kp_source = kp_detector(source_tensor)\n",
    "    kp_initial = None\n",
    "    crop_box = (143, 87, 322, 322)\n",
    "    count = 0\n",
    "\n",
    "    while True:\n",
    "        ret, frame = cap.read()\n",
    "        if not ret:\n",
    "            break\n",
    "\n",
    "        frame_processed = preprocess_frame(frame, crop_box)\n",
    "        frame_tensor = to_tensor(frame_processed, use_cpu=USE_CPU)\n",
    "\n",
    "        if kp_initial is None:\n",
    "            kp_initial = kp_detector(frame_tensor)\n",
    "\n",
    "        prediction = generate_frame(\n",
    "            source_tensor, kp_source, frame_tensor, kp_initial,\n",
    "            generator, kp_detector\n",
    "        )\n",
    "\n",
    "        # Join frames\n",
    "        joined = np.concatenate([\n",
    "            source_rgb,\n",
    "            cv2.cvtColor(prediction, cv2.COLOR_RGB2BGR),\n",
    "            frame_processed\n",
    "        ], axis=1)\n",
    "\n",
    "        # Add text-hint\n",
    "        cv2.putText(\n",
    "            joined, \"Press 'Q' to quit\", (10, 245),\n",
    "            cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2, cv2.LINE_AA\n",
    "        )\n",
    "\n",
    "        # Show and write\n",
    "        cv2.imshow(WINDOW_NAME, joined)\n",
    "        out_video.write(np.clip(joined * 255, 0, 255).astype(np.uint8))\n",
    "\n",
    "        if cv2.waitKey(20) & 0xFF == ord('q'):\n",
    "            break\n",
    "\n",
    "cap.release()\n",
    "out_video.release()\n",
    "cv2.destroyAllWindows()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "outputs": [],
   "source": [
    "with torch.no_grad():\n",
    "    kp_source = kp_detector(source_tensor)\n",
    "    kp_initial = None\n",
    "    crop_box = (143, 87, 322, 322)\n",
    "    count = 0\n",
    "\n",
    "    # while True:\n",
    "    ret, frame = cap.read()\n",
    "    # if not ret:\n",
    "    #     break\n",
    "\n",
    "    frame_processed = preprocess_frame(frame, crop_box)\n",
    "    frame_tensor = to_tensor(frame_processed, use_cpu=USE_CPU)\n",
    "\n",
    "    if kp_initial is None:\n",
    "        kp_initial = kp_detector(frame_tensor)\n",
    "\n",
    "    prediction = generate_frame(\n",
    "        source_tensor, kp_source, frame_tensor, kp_initial,\n",
    "        generator, kp_detector\n",
    "    )\n",
    "\n",
    "    # Join frames\n",
    "    joined = np.concatenate([\n",
    "        source_rgb,\n",
    "        cv2.cvtColor(prediction, cv2.COLOR_RGB2BGR),\n",
    "        frame_processed\n",
    "    ], axis=1)\n",
    "\n",
    "    # Show and write\n",
    "    cv2.imshow(WINDOW_NAME, joined)\n",
    "    out_video.write(np.clip(joined * 255, 0, 255).astype(np.uint8))\n",
    "\n",
    "    # if cv2.waitKey(20) & 0xFF == ord('q'):\n",
    "    #     break\n",
    "\n",
    "cap.release()\n",
    "out_video.release()\n",
    "cv2.destroyAllWindows()"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2025-05-18T08:29:57.885870800Z",
     "start_time": "2025-05-18T08:29:55.150820800Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "# Image Animation by Prepared Video"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "outputs": [],
   "source": [
    "service = VideoAnimationService(\n",
    "    config_path='./data/configs/vox-256.yaml',\n",
    "    checkpoint_path='./data/checkpoints/vox-cpk.pth.tar',\n",
    "    source_image_path='./data/input/monalisa.png',\n",
    "    driving_video_path='./data/input/my_face.mp4',\n",
    "    result_video_path='./data/output/result.mp4',\n",
    "    relative=False,\n",
    "    adapt_scale=False,\n",
    "    find_best=False,\n",
    "    best_frame=None,\n",
    "    cpu=True,\n",
    ")\n",
    "service.run()"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}



# Файл "app\__init__.py":




# Файл "app\data\configs\vox-256.yaml":

dataset_params:
  root_dir: data/vox-png
  frame_shape: [256, 256, 3]
  id_sampling: True
  pairs_list: data/vox256.csv
  augmentation_params:
    flip_param:
      horizontal_flip: True
      time_flip: True
    jitter_param:
      brightness: 0.1
      contrast: 0.1
      saturation: 0.1
      hue: 0.1


model_params:
  common_params:
    num_kp: 10
    num_channels: 3
    estimate_jacobian: True
  kp_detector_params:
     temperature: 0.1
     block_expansion: 32
     max_features: 1024
     scale_factor: 0.25
     num_blocks: 5
  generator_params:
    block_expansion: 64
    max_features: 512
    num_down_blocks: 2
    num_bottleneck_blocks: 6
    estimate_occlusion_map: True
    dense_motion_params:
      block_expansion: 64
      max_features: 1024
      num_blocks: 5
      scale_factor: 0.25
  discriminator_params:
    scales: [1]
    block_expansion: 32
    max_features: 512
    num_blocks: 4
    sn: True

train_params:
  num_epochs: 100
  num_repeats: 75
  epoch_milestones: [60, 90]
  lr_generator: 2.0e-4
  lr_discriminator: 2.0e-4
  lr_kp_detector: 2.0e-4
  batch_size: 40
  scales: [1, 0.5, 0.25, 0.125]
  checkpoint_freq: 50
  transform_params:
    sigma_affine: 0.05
    sigma_tps: 0.005
    points_tps: 5
  loss_weights:
    generator_gan: 0
    discriminator_gan: 1
    feature_matching: [10, 10, 10, 10]
    perceptual: [10, 10, 10, 10, 10]
    equivariance_value: 10
    equivariance_jacobian: 10

reconstruction_params:
  num_videos: 1000
  format: '.mp4'

animate_params:
  num_pairs: 50
  format: '.mp4'
  normalization_params:
    adapt_movement_scale: False
    use_relative_movement: True
    use_relative_jacobian: True

visualizer_params:
  kp_size: 5
  draw_border: True
  colormap: 'gist_rainbow'



# Файл "app\src\run_model.py":

import sys
from argparse import ArgumentParser, Namespace

import torch
from src.ml.runners import (
    AnimationRunner,
    ReconstructionRunner,
    TrainingRunner,
)
from src.ml.services.logging import LoggingService


def parse_args() -> Namespace:
    parser = ArgumentParser()
    parser.add_argument("--configs", required=True)
    parser.add_argument("--mode", choices=["train", "reconstruction", "animate"], required=True)
    parser.add_argument("--log_dir", default="log")
    parser.add_argument("--checkpoint", default=None)
    parser.add_argument("--device_ids", default="0", type=lambda x: list(map(int, x.split(","))))
    parser.add_argument("--verbose", action="store_true")
    return parser.parse_args()


if __name__ == "__main__":
    if sys.version_info[0] < 3:
        raise Exception("Use Python 3 or higher.")

    torch.multiprocessing.set_start_method("spawn", force=True)  # Safety for CUDA

    args = parse_args()
    log = LoggingService.setup_logger(__name__)

    mode_to_runner = {"train": TrainingRunner, "reconstruction": ReconstructionRunner, "animate": AnimationRunner}

    runner_class = mode_to_runner[args.mode]
    runner = runner_class(args, log)
    runner.run()



# Файл "app\src\run_server.py":

import logging

import src.server as server
from fastapi import Depends, FastAPI
from src.server.config import APIConfig, LogLevelEnum
from src.server.exceptions import app_exception_handler, exception_handlers
from src.server.routers import router as fomm_router

logging.basicConfig(format="[PID:%(process)d] %(pathname)s:%(lineno)d %(message)s", level=logging.INFO)
config = APIConfig()

app = FastAPI(
    title=f"{config.MODE.capitalize()} Animatica ML API",
    description="This API is designed for the Animatica application.",
    swagger_ui_parameters={"displayRequestDuration": True},
    version=server.__version__,
    debug=(config.LOG_LEVEL == LogLevelEnum.DEBUG),
)

app.include_router(fomm_router, prefix="/api", dependencies=[Depends(server.validate_api_key)])

for exc_type in exception_handlers:
    app.add_exception_handler(exc_type, app_exception_handler)



# Файл "app\src\__init__.py":




# Файл "app\src\ml\__init__.py":




# Файл "app\src\ml\datasets\dataset_repeater.py":

from torch.utils.data import Dataset


class DatasetRepeater(Dataset):
    """Pass several times over the same dataset for better i/o performance."""

    def __init__(self, dataset, num_repeats: int = 100) -> None:
        self.dataset = dataset
        self.num_repeats = num_repeats

    def __len__(self) -> int:
        return self.num_repeats * self.dataset.__len__()

    def __getitem__(self, idx: int):
        return self.dataset[idx % self.dataset.__len__()]



# Файл "app\src\ml\datasets\frames_dataset.py":

import glob
import os

import numpy as np
from skimage import io
from skimage.util import img_as_float32
from sklearn.model_selection import train_test_split
from src.ml.datasets.augmentation import AllAugmentationTransform
from src.ml.datasets.utils import read_video
from torch.utils.data import Dataset


class FramesDataset(Dataset):
    """
    Dataset of videos, each video can be represented as:
      - an image of concatenated frames
      - '.mp4' or '.gif'
      - folder with all frames
    """

    def __init__(
        self,
        root_dir: str,
        frame_shape=(256, 256, 3),
        id_sampling: bool = False,
        is_train: bool = True,
        random_seed=0,
        pairs_list=None,
        augmentation_params=None,
    ) -> None:
        self.root_dir = root_dir
        self.videos = os.listdir(root_dir)
        self.frame_shape = tuple(frame_shape)
        self.pairs_list = pairs_list
        self.id_sampling = id_sampling
        if os.path.exists(os.path.join(root_dir, "train")):
            assert os.path.exists(os.path.join(root_dir, "test"))
            print("Use predefined train-test split.")
            if id_sampling:
                train_videos = {
                    os.path.basename(video).split("#")[0] for video in os.listdir(os.path.join(root_dir, "train"))
                }
                train_videos = list(train_videos)
            else:
                train_videos = os.listdir(os.path.join(root_dir, "train"))
            test_videos = os.listdir(os.path.join(root_dir, "test"))
            self.root_dir = os.path.join(self.root_dir, "train" if is_train else "test")
        else:
            print("Use random train-test split.")
            train_videos, test_videos = train_test_split(self.videos, random_state=random_seed, test_size=0.2)

        self.videos = train_videos if is_train else test_videos
        self.transform = AllAugmentationTransform(**augmentation_params) if is_train else None
        self.is_train = is_train

    def __len__(self) -> int:
        return len(self.videos)

    def __getitem__(self, idx: int):
        if self.is_train and self.id_sampling:
            name = self.videos[idx]
            path = np.random.choice(glob.glob(os.path.join(self.root_dir, name + "*.mp4")))
        else:
            name = self.videos[idx]
            path = os.path.join(self.root_dir, name)

        video_name = os.path.basename(path)

        if self.is_train and os.path.isdir(path):
            frames = os.listdir(path)
            num_frames = len(frames)
            frame_idx = np.sort(np.random.choice(num_frames, replace=True, size=2))
            video_array = [img_as_float32(io.imread(os.path.join(path, frames[idx]))) for idx in frame_idx]
        else:
            video_array = read_video(path, frame_shape=self.frame_shape)
            num_frames = len(video_array)
            frame_idx = (
                np.sort(np.random.choice(num_frames, replace=True, size=2)) if self.is_train else range(num_frames)
            )
            video_array = video_array[frame_idx]

        if self.transform is not None:
            video_array = self.transform(video_array)

        out = {}
        if self.is_train:
            source = np.array(video_array[0], dtype="float32")
            driving = np.array(video_array[1], dtype="float32")

            out["driving"] = driving.transpose((2, 0, 1))
            out["source"] = source.transpose((2, 0, 1))
        else:
            video = np.array(video_array, dtype="float32")
            out["video"] = video.transpose((3, 0, 1, 2))

        out["name"] = video_name

        return out



# Файл "app\src\ml\datasets\paired_dataset.py":

import numpy as np
import pandas as pd
from torch.utils.data import Dataset


class PairedDataset(Dataset):
    """Dataset of pairs for services."""

    def __init__(self, initial_dataset, number_of_pairs: int, seed=0) -> None:
        self.initial_dataset = initial_dataset
        pairs_list = self.initial_dataset.pairs_list

        np.random.seed(seed)

        if not pairs_list:
            max_idx = min(number_of_pairs, len(initial_dataset))
            nx, ny = max_idx, max_idx
            xy = np.mgrid[:nx, :ny].reshape(2, -1).T
            number_of_pairs = min(xy.shape[0], number_of_pairs)
            self.pairs = xy.take(np.random.choice(xy.shape[0], number_of_pairs, replace=False), axis=0)
        else:
            videos = self.initial_dataset.videos
            name_to_index = {name: index for index, name in enumerate(videos)}
            pairs = pd.read_csv(pairs_list)
            pairs = pairs[np.logical_and(pairs["source"].isin(videos), pairs["driving"].isin(videos))]

            number_of_pairs = min(pairs.shape[0], number_of_pairs)
            self.pairs = []
            self.start_frames = []
            for ind in range(number_of_pairs):
                self.pairs.append((name_to_index[pairs["driving"].iloc[ind]], name_to_index[pairs["source"].iloc[ind]]))

    def __len__(self) -> int:
        return len(self.pairs)

    def __getitem__(self, idx: int):
        pair = self.pairs[idx]
        first = self.initial_dataset[pair[0]]
        second = self.initial_dataset[pair[1]]
        first = {"driving_" + key: value for key, value in first.items()}
        second = {"source_" + key: value for key, value in second.items()}

        return {**first, **second}



# Файл "app\src\ml\datasets\replicate.py":

import functools

import torch
import torch.nn as nn
from torch.nn.parallel.data_parallel import DataParallel


class CallbackContext:
    pass


def execute_replication_callbacks(modules):
    """
    Execute a replication callback `__data_parallel_replicate__` on each module created by original replication.

    The callback will be invoked with arguments `__data_parallel_replicate__(ctx, copy_id)`

    Note that, as all modules are isomorphism, we assign each submodule with a context
    (shared among multiple copies of this module on different devices).
    Through this context, different copies can share some information.

    We guarantee that the callback on the master copy (the first copy) will be called ahead of calling the callback
    of any slave copies.
    """
    master_copy = modules[0]
    nr_modules = len(list(master_copy.modules()))
    ctxs = [CallbackContext() for _ in range(nr_modules)]

    for i, module in enumerate(modules):
        for j, m in enumerate(module.modules()):
            if hasattr(m, "__data_parallel_replicate__"):
                m.__data_parallel_replicate__(ctxs[j], i)


class DataParallelWithCallback(DataParallel):
    """
    Data Parallel with a replication callback.

    A replication callback `__data_parallel_replicate__` of each module will be invoked after being created by
    original `replicate` function.
    The callback will be invoked with arguments `__data_parallel_replicate__(ctx, copy_id)`

    Examples:
        > sync_bn = SynchronizedBatchNorm1d(10, eps=1e-5, affine=False)
        > sync_bn = DataParallelWithCallback(sync_bn, device_ids=[0, 1])
        # sync_bn.__data_parallel_replicate__ will be invoked.
    """

    def replicate(self, module, device_ids):
        modules = super().replicate(module, device_ids)
        execute_replication_callbacks(modules)
        return modules


def patch_replication_callback(data_parallel):
    """
    Monkey-patch an existing `DataParallel` object. Add the replication callback.
    Useful when you have customized `DataParallel` implementation.

    Examples:
        > sync_bn = SynchronizedBatchNorm1d(10, eps=1e-5, affine=False)
        > sync_bn = DataParallel(sync_bn, device_ids=[0, 1])
        > patch_replication_callback(sync_bn)
        # this is equivalent to
        > sync_bn = SynchronizedBatchNorm1d(10, eps=1e-5, affine=False)
        > sync_bn = DataParallelWithCallback(sync_bn, device_ids=[0, 1])
    """

    assert isinstance(data_parallel, DataParallel)

    old_replicate = data_parallel.replicate

    @functools.wraps(old_replicate)
    def new_replicate(module, device_ids):
        modules = old_replicate(module, device_ids)
        execute_replication_callbacks(modules)
        return modules

    data_parallel.replicate = new_replicate


def ddp_callback_wrapper(module: nn.Module, rank: int = None):
    ctxs = {}
    for idx, m in enumerate(module.modules()):
        if hasattr(m, "__data_parallel_replicate__") and idx not in ctxs:
            ctx = CallbackContext()
            m.__data_parallel_replicate__(ctx, rank if rank is not None else torch.distributed.get_rank())
            ctxs[idx] = ctx
    return ctxs



# Файл "app\src\ml\datasets\utils.py":

import os

import numpy as np
from imageio.v2 import mimread
from skimage import io
from skimage.color import gray2rgb
from skimage.util import img_as_float32


def read_video(name, frame_shape):
    """
    Read video which can be:
      - an image of concatenated frames
      - '.mp4' and'.gif'
      - folder with videos
    """
    if os.path.isdir(name):
        frames = sorted(os.listdir(name))
        num_frames = len(frames)
        video_array = np.array(
            [img_as_float32(io.imread(os.path.join(name, frames[idx]))) for idx in range(num_frames)]
        )
    elif name.lower().endswith(".png") or name.lower().endswith(".jpg"):
        image = io.imread(name)

        if len(image.shape) == 2 or image.shape[2] == 1:
            image = gray2rgb(image)

        if image.shape[2] == 4:
            image = image[..., :3]

        image = img_as_float32(image)

        video_array = np.moveaxis(image, 1, 0)

        video_array = video_array.reshape((-1,) + frame_shape)
        video_array = np.moveaxis(video_array, 1, 2)
    elif name.lower().endswith(".gif") or name.lower().endswith(".mp4") or name.lower().endswith(".mov"):
        video = np.array(mimread(name))
        if len(video.shape) == 3:
            video = np.array([gray2rgb(frame) for frame in video])
        if video.shape[-1] == 4:
            video = video[..., :3]
        video_array = img_as_float32(video)
    else:
        raise Exception("Unknown file extensions  %s" % name)

    return video_array



# Файл "app\src\ml\datasets\__init__.py":

from .frames_dataset import FramesDataset
from .paired_dataset import PairedDataset



# Файл "app\src\ml\datasets\augmentation\all_transforms.py":

from src.ml.datasets.augmentation.transforms import (
    ColorJitter,
    RandomCrop,
    RandomFlip,
    RandomResize,
    RandomRotation,
)


class AllAugmentationTransform:
    def __init__(
        self, resize_param=None, rotation_param=None, flip_param=None, crop_param=None, jitter_param=None
    ) -> None:
        self.transforms = []

        params = {
            RandomFlip: flip_param,
            RandomRotation: rotation_param,
            RandomResize: resize_param,
            RandomCrop: crop_param,
            ColorJitter: jitter_param,
        }
        for Factory, param in params.items():
            if param:
                self.transforms.append(Factory(**param))

    def __call__(self, clip):
        for t in self.transforms:
            clip = t(clip)
        return clip



# Файл "app\src\ml\datasets\augmentation\utils.py":

import numpy as np
import PIL
from skimage.transform import resize


def is_numpy_clip(clip) -> bool:
    return isinstance(clip[0], np.ndarray)


def is_pil_clip(clip) -> bool:
    return isinstance(clip[0], PIL.Image.Image)


def get_clip_shape(clip):
    if is_numpy_clip(clip):
        return clip[0].shape[:2]
    elif is_pil_clip(clip):
        return clip[0].size[1], clip[0].size[0]
    raise TypeError(f"Unsupported clip type: {type(clip[0])}")


def crop_clip(clip, min_h: int, min_w: int, h: int, w: int):
    if is_numpy_clip(clip):
        return [img[min_h : min_h + h, min_w : min_w + w, :] for img in clip]
    elif is_pil_clip(clip):
        return [img.crop((min_w, min_h, min_w + w, min_h + h)) for img in clip]
    else:
        raise TypeError("Expected numpy.ndarray or PIL.Image" + "but got list of {0}".format(type(clip[0])))


def pad_clip(clip, h: int, w: int):
    im_h, im_w = clip[0].shape[:2]
    pad_h = (0, 0) if h < im_h else ((h - im_h) // 2, (h - im_h + 1) // 2)
    pad_w = (0, 0) if w < im_w else ((w - im_w) // 2, (w - im_w + 1) // 2)
    return np.pad(clip, ((0, 0), pad_h, pad_w, (0, 0)), mode="edge")


def get_resize_sizes(im_h: int, im_w: int, size: int):
    if im_w < im_h:
        ow = size
        oh = int(size * im_h / im_w)
    else:
        oh = size
        ow = int(size * im_w / im_h)
    return oh, ow


def resize_clip(clip, size: int | tuple[int, int], interpolation: str = "bilinear"):
    if isinstance(size, int):
        im_h, im_w = get_clip_shape(clip)
        if (im_w <= im_h and im_w == size) or (im_h <= im_w and im_h == size):
            return clip
        new_h, new_w = get_resize_sizes(im_h, im_w, size)
        size = (new_w, new_h)
    else:
        size = size[1], size[0]

    if is_numpy_clip(clip):
        order = 1 if interpolation == "bilinear" else 0
        return [
            resize(img, size, order=order, preserve_range=True, mode="constant", anti_aliasing=True) for img in clip
        ]
    elif is_pil_clip(clip):
        pil_inter = PIL.Image.BILINEAR if interpolation == "bilinear" else PIL.Image.NEAREST
        return [img.resize(size, pil_inter) for img in clip]
    else:
        raise TypeError(f"Unsupported clip type: {type(clip[0])}")



# Файл "app\src\ml\datasets\augmentation\__init__.py":

from .all_transforms import AllAugmentationTransform



# Файл "app\src\ml\datasets\augmentation\transforms\color_jitter.py":

import random

import numpy as np
import torchvision
from skimage.util import img_as_float, img_as_ubyte
from src.ml.datasets.augmentation.utils import is_numpy_clip, is_pil_clip


class ColorJitter:
    """Randomly change the brightness, contrast and saturation and hue of the clip.
    Args:
        brightness (float): How much to jitter brightness. brightness_factor
                            is chosen uniformly from [max(0, 1 - brightness), 1 + brightness].
        contrast (float): How much to jitter contrast. contrast_factor
                          is chosen uniformly from [max(0, 1 - contrast), 1 + contrast].
        saturation (float): How much to jitter saturation. saturation_factor
                            is chosen uniformly from [max(0, 1 - saturation), 1 + saturation].
        hue(float): How much to jitter hue. hue_factor is chosen uniformly from
                    [-hue, hue]. Should be >=0 and <= 0.5.
    """

    def __init__(self, brightness: float = 0, contrast: float = 0, saturation: float = 0, hue: float = 0) -> None:
        self.brightness = brightness
        self.contrast = contrast
        self.saturation = saturation
        self.hue = hue

    @staticmethod
    def get_params(brightness: float, contrast: float, saturation: float, hue: float):
        return (
            random.uniform(max(0.0, 1 - brightness), 1 + brightness) if brightness > 0 else None,
            random.uniform(max(0.0, 1 - contrast), 1 + contrast) if contrast > 0 else None,
            random.uniform(max(0.0, 1 - saturation), 1 + saturation) if saturation > 0 else None,
            random.uniform(-hue, hue) if hue > 0 else None,
        )

    def __call__(self, clip):
        """
        Args:
            clip (list): list of PIL.Image
        Returns:
            list PIL.Image : list of transformed PIL.Image
        """
        return self.apply_color_jitter(clip, self.brightness, self.contrast, self.saturation, self.hue)

    @staticmethod
    def apply_pipeline(img, transforms):
        for t in transforms:
            img = t(img)
        return img

    @classmethod
    def apply_color_jitter(cls, clip, brightness: float, contrast: float, saturation: float, hue: float) -> list:
        brightness, contrast, saturation, hue = ColorJitter.get_params(brightness, contrast, saturation, hue)
        transforms = []
        if brightness:
            transforms.append(lambda img: torchvision.transforms.functional.adjust_brightness(img, brightness))
        if saturation:
            transforms.append(lambda img: torchvision.transforms.functional.adjust_saturation(img, saturation))
        if hue:
            transforms.append(lambda img: torchvision.transforms.functional.adjust_hue(img, hue))
        if contrast:
            transforms.append(lambda img: torchvision.transforms.functional.adjust_contrast(img, contrast))
        random.shuffle(transforms)

        if is_numpy_clip(clip):
            img_transforms = [img_as_ubyte, torchvision.transforms.ToPILImage()] + transforms + [np.array, img_as_float]
            return [cls.apply_pipeline(img, img_transforms) for img in clip]
        elif is_pil_clip(clip):
            return [cls.apply_pipeline(img, transforms) for img in clip]
        else:
            raise TypeError(f"Unsupported clip type: {type(clip[0])}")



# Файл "app\src\ml\datasets\augmentation\transforms\random_crop.py":

import random

from src.ml.datasets.augmentation.utils import (
    crop_clip,
    is_numpy_clip,
    is_pil_clip,
    pad_clip,
)


class RandomCrop:
    """Extract random crop at the same location for a list of videos.
    Args:
        size (sequence or int): Desired output size for the crop in format (h, w)
    """

    def __init__(self, size: int | tuple[int, int]) -> None:
        self.size = (size, size) if isinstance(size, int) else size

    def __call__(self, clip):
        """
        Args:
            img (PIL.Image or numpy.ndarray): List of videos to be cropped in format (h, w, c) in numpy.ndarray
        Returns:
            PIL.Image or numpy.ndarray: Cropped list of videos
        """
        h, w = self.size
        if is_numpy_clip(clip):
            im_h, im_w, im_c = clip[0].shape
        elif is_pil_clip(clip):
            im_w, im_h = clip[0].size
        else:
            raise TypeError("Expected numpy.ndarray or PIL.Image" + "but got list of {0}".format(type(clip[0])))

        clip = pad_clip(clip, h, w)
        im_h, im_w = clip.shape[1:3]
        x1 = 0 if h == im_h else random.randint(0, im_w - w)
        y1 = 0 if w == im_w else random.randint(0, im_h - h)
        cropped = crop_clip(clip, y1, x1, h, w)

        return cropped



# Файл "app\src\ml\datasets\augmentation\transforms\random_flip.py":

import random

import numpy as np


class RandomFlip:
    def __init__(self, time_flip: bool = False, horizontal_flip: bool = False) -> None:
        self.time_flip = time_flip
        self.horizontal_flip = horizontal_flip

    def __call__(self, clip):
        if random.random() < 0.5 and self.time_flip:
            clip = clip[::-1]
        if random.random() < 0.5 and self.horizontal_flip:
            clip = [np.fliplr(img) for img in clip]
        return clip



# Файл "app\src\ml\datasets\augmentation\transforms\random_resize.py":

import random

from src.ml.datasets.augmentation.utils import (
    is_numpy_clip,
    is_pil_clip,
    resize_clip,
)


class RandomResize:
    """Resizes a list of (H x W x C) numpy.ndarray to the final size.
    The larger the original image is, the more times it takes to interpolate
    Args:
        interpolation (str): Can be one of 'nearest', 'bilinear' defaults to nearest
        ratio (tuple): (widht, height)
    """

    def __init__(self, ratio: tuple[float] = (3.0 / 4.0, 4.0 / 3.0), interpolation: str = "nearest") -> None:
        self.ratio = ratio
        self.interpolation = interpolation

    def __call__(self, clip):
        scaling_factor = random.uniform(self.ratio[0], self.ratio[1])

        if is_numpy_clip(clip):
            im_h, im_w, im_c = clip[0].shape
        elif is_pil_clip(clip):
            im_w, im_h = clip[0].size

        new_w = int(im_w * scaling_factor)
        new_h = int(im_h * scaling_factor)
        new_size = (new_w, new_h)
        resized = resize_clip(clip, new_size, interpolation=self.interpolation)

        return resized



# Файл "app\src\ml\datasets\augmentation\transforms\random_rotation.py":

import random

from skimage.transform import rotate
from src.ml.datasets.augmentation.utils import is_numpy_clip, is_pil_clip


class RandomRotation:
    """Rotate entire clip randomly by a random angle within given bounds.
    Args:
        degrees (sequence or int): Range of degrees to select from
                                   If degrees is a number instead of sequence like (min, max),
                                   the range of degrees, will be (-degrees, +degrees).
    """

    def __init__(self, degrees: int | tuple) -> None:
        if isinstance(degrees, int):
            if degrees < 0:
                raise ValueError("If degrees is a single number," "must be positive")
            degrees = (-degrees, degrees)
        else:
            if len(degrees) != 2:
                raise ValueError("If degrees is a sequence," "it must be of len 2.")

        self.degrees = degrees

    def __call__(self, clip):
        """
        Args:
            clip (PIL.Image or numpy.ndarray): List of videos to be cropped in format (h, w, c) in numpy.ndarray
        Returns:
            PIL.Image or numpy.ndarray: Cropped list of videos
        """
        angle = random.uniform(self.degrees[0], self.degrees[1])
        if is_numpy_clip(clip):
            rotated = [rotate(image=img, angle=angle, preserve_range=True) for img in clip]
        elif is_pil_clip(clip):
            rotated = [img.rotate(angle) for img in clip]
        else:
            raise TypeError("Expected numpy.ndarray or PIL.Image" + "but got list of {0}".format(type(clip[0])))

        return rotated



# Файл "app\src\ml\datasets\augmentation\transforms\__init__.py":

from .color_jitter import ColorJitter
from .random_crop import RandomCrop
from .random_flip import RandomFlip
from .random_resize import RandomResize
from .random_rotation import RandomRotation



# Файл "app\src\ml\modules\__init__.py":




# Файл "app\src\ml\modules\blocks\anti_alias.py":

import torch
import torch.nn.functional as F


class AntiAliasInterpolation2d(torch.nn.Module):
    """Band-limited downsampling with antialiasing for better signal preservation.
    Args:
        channels: Number of input channels
        scale: Scaling factor (must be <= 1.0 for downsampling)
    """

    def __init__(self, channels: int, scale: float) -> None:
        super().__init__()
        if scale > 1.0:
            raise ValueError("Scale factor must be <= 1.0 for anti-aliased downsampling")

        self.scale = scale
        self.groups = channels

        if scale == 1.0:
            return  # Identity operation

        # Calculate optimal Gaussian kernel
        sigma = (1 / scale - 1) / 2
        kernel_size = 2 * round(sigma * 4) + 1
        self.ka = kernel_size // 2
        self.kb = kernel_size - self.ka - 1  # More efficient padding calculation

        # Vectorized kernel creation
        grid = torch.arange(kernel_size, dtype=torch.float32) - (kernel_size - 1) / 2
        x, y = torch.meshgrid(grid, grid, indexing="ij")
        kernel = torch.exp(-(x**2 + y**2) / (2 * sigma**2))
        kernel = kernel / kernel.sum()  # Normalize

        # Register as buffer for proper device handling
        self.register_buffer(
            "weight", kernel.view(1, 1, kernel_size, kernel_size).expand(channels, -1, -1, -1).contiguous()
        )

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        if self.scale == 1.0:
            return x

        x = F.pad(x, (self.ka, self.kb, self.ka, self.kb))
        x = F.conv2d(x, weight=self.weight, groups=self.groups)
        x = F.interpolate(x, scale_factor=(self.scale, self.scale))

        return x



# Файл "app\src\ml\modules\blocks\conv_blocks.py":

import torch.nn.functional as F
from torch import Tensor, nn
from torch.nn import BatchNorm2d


class ResBlock2d(nn.Module):
    """Res block, preserve spatial resolution."""

    def __init__(self, in_features: int, kernel_size: int | tuple[int, int], padding: int | tuple[int, int]) -> None:
        super().__init__()
        self.conv1 = nn.Conv2d(in_features, in_features, kernel_size, padding=padding)
        self.conv2 = nn.Conv2d(in_features, in_features, kernel_size, padding=padding)
        self.norm1 = BatchNorm2d(in_features, affine=True)
        self.norm2 = BatchNorm2d(in_features, affine=True)

    def forward(self, x: Tensor) -> Tensor:
        out = F.relu(self.norm1(x))
        out = F.relu(self.norm2(self.conv1(out)))
        return self.conv2(out) + x


class UpBlock2d(nn.Module):
    """Upsampling block for use in decoder."""

    def __init__(
        self, in_features: int, out_features: int, kernel_size: int = 3, padding: int = 1, groups: int = 1
    ) -> None:
        super().__init__()
        self.conv = nn.Conv2d(in_features, out_features, kernel_size, padding=padding, groups=groups)
        self.norm = BatchNorm2d(out_features, affine=True)

    def forward(self, x: Tensor) -> Tensor:
        out = F.interpolate(x, scale_factor=2)
        return F.relu(self.norm(self.conv(out)))


class DownBlock2d(nn.Module):
    """Downsampling block for use in encoder."""

    def __init__(
        self, in_features: int, out_features: int, kernel_size: int = 3, padding: int = 1, groups: int = 1
    ) -> None:
        super().__init__()
        self.conv = nn.Conv2d(in_features, out_features, kernel_size, padding=padding, groups=groups)
        self.norm = BatchNorm2d(out_features, affine=True)
        self.pool = nn.AvgPool2d(kernel_size=(2, 2))

    def forward(self, x: Tensor) -> Tensor:
        return self.pool(F.relu(self.norm(self.conv(x))))


class SameBlock2d(nn.Module):
    """Simple block, preserve spatial resolution."""

    def __init__(
        self,
        in_features: int,
        out_features: int,
        groups: int = 1,
        kernel_size: int | tuple[int, int] = 3,
        padding: int | tuple[int, int] = 1,
    ) -> None:
        super().__init__()
        self.conv = nn.Conv2d(in_features, out_features, kernel_size, padding=padding, groups=groups)
        self.norm = BatchNorm2d(out_features, affine=True)

    def forward(self, x: Tensor) -> Tensor:
        return F.relu(self.norm(self.conv(x)))



# Файл "app\src\ml\modules\blocks\decoder.py":

import torch
from src.ml.modules.blocks.conv_blocks import UpBlock2d
from torch import nn


class Decoder(nn.Module):
    """Hourglass Decoder."""

    def __init__(self, block_expansion: int, in_features: int, num_blocks: int = 3, max_features: int = 256) -> None:
        super().__init__()

        def num_channels(scale):
            return min(max_features, block_expansion * (2**scale))

        self.up_blocks = nn.ModuleList(
            [
                UpBlock2d(
                    in_features=(1 if i == num_blocks - 1 else 2) * num_channels(i + 1), out_features=num_channels(i)
                )
                for i in reversed(range(num_blocks))
            ]
        )

        self.out_filters = block_expansion + in_features

    def forward(self, x):
        out = x.pop()
        for block in self.up_blocks:
            out = block(out)
            skip = x.pop()
            out = torch.cat([out, skip], dim=1)
        return out



# Файл "app\src\ml\modules\blocks\encoder.py":

from src.ml.modules.blocks.conv_blocks import DownBlock2d
from torch import nn


class Encoder(nn.Module):
    """Hourglass Encoder."""

    def __init__(self, block_expansion: int, in_features: int, num_blocks: int = 3, max_features: int = 256) -> None:
        super().__init__()

        def num_channels(scale) -> int:
            return min(max_features, block_expansion * (2**scale))

        self.down_blocks = nn.ModuleList(
            [
                DownBlock2d(in_features=in_features if i == 0 else num_channels(i), out_features=num_channels(i + 1))
                for i in range(num_blocks)
            ]
        )

    def forward(self, x):
        outs = [x]
        for block in self.down_blocks:
            outs.append(block(outs[-1]))
        return outs



# Файл "app\src\ml\modules\blocks\hourglass.py":

from src.ml.modules.blocks.decoder import Decoder
from src.ml.modules.blocks.encoder import Encoder
from torch import Tensor, nn


class Hourglass(nn.Module):
    """Hourglass architecture."""

    def __init__(self, block_expansion: int, in_features: int, num_blocks: int = 3, max_features: int = 256) -> None:
        super().__init__()
        self.encoder = Encoder(block_expansion, in_features, num_blocks, max_features)
        self.decoder = Decoder(block_expansion, in_features, num_blocks, max_features)
        self.out_filters = self.decoder.out_filters

    def forward(self, x: Tensor) -> Tensor:
        return self.decoder(self.encoder(x))



# Файл "app\src\ml\modules\blocks\__init__.py":

from .anti_alias import AntiAliasInterpolation2d
from .conv_blocks import DownBlock2d, ResBlock2d, SameBlock2d, UpBlock2d
from .decoder import Decoder
from .encoder import Encoder
from .hourglass import Hourglass



# Файл "app\src\ml\modules\dense_motion\dense_motion.py":

import torch
import torch.nn.functional as F
from src.ml.modules.blocks import AntiAliasInterpolation2d, Hourglass
from src.ml.modules.utils.utils import kp2gaussian, make_coordinate_grid
from torch import nn


class DenseMotionNetwork(nn.Module):
    """Predicts dense motion from sparse keypoint representations using hourglass architecture."""

    def __init__(
        self,
        block_expansion: int,
        num_blocks: int,
        max_features: int,
        num_kp: int,
        num_channels: int,
        estimate_occlusion_map: bool = False,
        scale_factor: int = 1,
        kp_variance: float = 0.01,
    ) -> None:
        super().__init__()
        self.num_kp = num_kp
        self.scale_factor = scale_factor
        self.kp_variance = kp_variance

        # Input feature calculation (K+1)*(C+1) for heatmaps and deformed features
        in_features = (num_kp + 1) * (num_channels + 1)

        # Core components
        self.hourglass = Hourglass(block_expansion, in_features, num_blocks, max_features)

        # Output layers
        self.mask = nn.Conv2d(self.hourglass.out_filters, num_kp + 1, kernel_size=7, padding=3)
        self.occlusion = (
            nn.Conv2d(self.hourglass.out_filters, 1, kernel_size=7, padding=3) if estimate_occlusion_map else None
        )

        # Preprocessing
        self.down = AntiAliasInterpolation2d(num_channels, scale_factor) if scale_factor != 1 else None

    def create_heatmap_representations(
        self, source_image: torch.Tensor, kp_driving: dict, kp_source: dict
    ) -> torch.Tensor:
        """Generates heatmap representations for keypoint differences."""
        spatial_size = source_image.shape[2:]
        gaussian_driving = kp2gaussian(kp_driving, spatial_size=spatial_size, kp_variance=self.kp_variance)
        gaussian_source = kp2gaussian(kp_source, spatial_size=spatial_size, kp_variance=self.kp_variance)

        # Add background channel
        heatmaps = torch.cat(
            [torch.zeros_like(gaussian_driving[:, :1]), gaussian_driving - gaussian_source], dim=1  # Background
        )

        return heatmaps.unsqueeze(2)  # Add dimension for concatenation

    def create_sparse_motions(self, source_image: torch.Tensor, kp_driving: dict, kp_source: dict) -> torch.Tensor:
        """Computes sparse motion transformations between keypoints."""
        bs, _, h, w = source_image.shape
        device = source_image.device

        # Create base coordinate grid
        identity_grid = make_coordinate_grid((h, w), kp_source["value"].type()).to(device)
        identity_grid = identity_grid.view(1, 1, h, w, 2)

        # Calculate driving to source transformation
        coordinate_grid = identity_grid - kp_driving["value"].view(bs, self.num_kp, 1, 1, 2)

        # Apply Jacobian transformation if available
        if "jacobian" in kp_driving:
            jacobian = torch.matmul(kp_source["jacobian"], torch.inverse(kp_driving["jacobian"]))
            jacobian = jacobian.view(bs, self.num_kp, 1, 1, 2, 2)
            coordinate_grid = torch.einsum("bkhwij,bkhwj->bkhwi", jacobian, coordinate_grid)

        driving_to_source = coordinate_grid + kp_source["value"].view(bs, self.num_kp, 1, 1, 2)

        # Combine with identity grid for background
        return torch.cat([identity_grid.expand(bs, -1, h, w, 2), driving_to_source], dim=1)

    def _compute_deformation(self, sparse_motions: torch.Tensor, mask: torch.Tensor) -> torch.Tensor:
        """Computes final deformation field using predicted masks."""
        return torch.einsum("bkhw,bkhwc->bhwc", mask, sparse_motions.permute(0, 1, 4, 2, 3))

    def create_deformed_source_image(self, source_image: torch.Tensor, sparse_motions: torch.Tensor) -> torch.Tensor:
        """Warps source image using computed sparse motions."""
        bs, _, h, w = source_image.shape

        # Prepare source image for warping
        source_expanded = source_image.unsqueeze(1).expand(-1, self.num_kp + 1, -1, -1, -1)
        source_expanded = source_expanded.reshape(bs * (self.num_kp + 1), -1, h, w)

        # Perform grid sampling
        motions_flat = sparse_motions.view(bs * (self.num_kp + 1), h, w, 2)
        deformed = F.grid_sample(source_expanded, motions_flat, align_corners=True)

        return deformed.view(bs, self.num_kp + 1, -1, h, w)

    def forward(self, source_image: torch.Tensor, kp_driving: dict, kp_source: dict) -> dict[str, torch.Tensor]:
        # Preprocess input
        if self.down:
            source_image = self.down(source_image)

        bs, _, h, w = source_image.shape
        out_dict = dict()

        # Compute motion components
        heatmaps = self.create_heatmap_representations(source_image, kp_driving, kp_source)
        sparse_motions = self.create_sparse_motions(source_image, kp_driving, kp_source)
        deformed_source = self.create_deformed_source_image(source_image, sparse_motions)
        out_dict["sparse_deformed"] = deformed_source

        hourglass_input = torch.cat([heatmaps, deformed_source], dim=2)
        hourglass_input = hourglass_input.view(bs, -1, h, w)
        prediction = self.hourglass(hourglass_input)
        mask = F.softmax(self.mask(prediction), dim=1)
        out_dict["mask"] = mask

        mask = mask.unsqueeze(2)
        sparse_motions = sparse_motions.permute(0, 1, 4, 2, 3)
        deformation = (sparse_motions * mask).sum(dim=1)
        deformation = deformation.permute(0, 2, 3, 1)
        out_dict["deformation"] = deformation

        # Add occlusion map if needed
        if self.occlusion:
            out_dict["occlusion_map"] = torch.sigmoid(self.occlusion(prediction))

        return out_dict



# Файл "app\src\ml\modules\dense_motion\__init__.py":

from .dense_motion import DenseMotionNetwork



# Файл "app\src\ml\modules\discriminator\blocks.py":

import torch
import torch.nn.functional as F
from torch import nn


class DownBlock2d(nn.Module):
    """Simple block for processing video (encoder).
    Args:
        in_features (int): Number of input channels.
        out_features (int): Number of output channels.
        norm (bool): Whether to use InstanceNorm2d.
        kernel_size (int): Size of the convolutional kernel.
        pool (bool): Whether to apply average pooling.
        sn (bool): Whether to apply spectral normalization.
    """

    def __init__(
        self,
        in_features: int,
        out_features: int,
        norm: bool = False,
        kernel_size: int = 4,
        pool: bool = False,
        sn: bool = False,
    ) -> None:
        super().__init__()
        self.conv = nn.Conv2d(in_channels=in_features, out_channels=out_features, kernel_size=kernel_size)
        self.conv = nn.utils.spectral_norm(self.conv) if sn else self.conv
        self.norm: nn.Module = nn.InstanceNorm2d(out_features, affine=True) if norm else nn.Identity()
        self.pool: nn.Module = nn.AvgPool2d(kernel_size=2) if pool else nn.Identity()

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x = self.conv(x)
        x = self.norm(x)
        x = F.leaky_relu(x, 0.2)
        x = self.pool(x)
        return x



# Файл "app\src\ml\modules\discriminator\discriminator_full_model.py":

import torch
from src.ml.modules.utils import ImagePyramide
from src.ml.modules.utils.utils import detach_kp
from torch import nn


class DiscriminatorFullModel(torch.nn.Module):
    """Wraps the discriminator forward pass and GAN loss calculation for improved multi-GPU usage."""

    def __init__(self, kp_extractor, generator: nn.Module, discriminator: nn.Module, train_params: dict) -> None:
        super().__init__()
        self.kp_extractor = kp_extractor
        self.generator = generator
        self.discriminator = discriminator
        self.train_params = train_params

        self.scales = self.discriminator.scales
        self.loss_weights = train_params["loss_weights"]

        self.pyramid = ImagePyramide(self.scales, generator.num_channels)
        if torch.cuda.is_available():
            self.pyramid = self.pyramid.cuda()

    def forward(self, x: dict, generated: dict) -> dict[str, float]:
        # Extract pyramids for real and generated frames
        pyramide_real = self.pyramid(x["driving"])
        pyramide_fake = self.pyramid(generated["prediction"].detach())

        # Detach keypoints to stop gradient to generator
        kp_driving_detached = detach_kp(generated["kp_driving"])

        # Run discriminator
        disc_fake = self.discriminator(pyramide_fake, kp=kp_driving_detached)
        disc_real = self.discriminator(pyramide_real, kp=kp_driving_detached)

        # Compute GAN loss (LSGAN formulation)
        disc_loss_total = 0.0
        for scale in self.scales:
            key = f"prediction_map_{scale}"
            real_map = disc_real[key]
            fake_map = disc_fake[key]
            scale_loss = (1 - real_map) ** 2 + fake_map**2
            disc_loss_total += self.loss_weights["discriminator_gan"] * scale_loss.mean()

        return {"disc_gan": disc_loss_total}



# Файл "app\src\ml\modules\discriminator\multi_scale_discriminator.py":

import torch
from src.ml.modules.discriminator.pix2pix_discriminator import Discriminator
from torch import nn


class MultiScaleDiscriminator(nn.Module):
    """Discriminator that processes inputs at multiple spatial scales."""

    def __init__(self, scales=(), **kwargs) -> None:
        super().__init__()
        self.scales = scales

        discs = {}
        for scale in scales:
            discs[str(scale).replace(".", "-")] = Discriminator(**kwargs)
        self.discs = nn.ModuleDict(discs)

    def forward(self, x: dict, kp=None) -> dict[str, torch.Tensor] | list[torch.Tensor]:
        out_dict = {}

        for scale, disc in self.discs.items():
            scale = str(scale).replace("-", ".")
            key = f"prediction_{scale}"

            feature_maps, prediction_map = disc(x[key], kp)

            out_dict[f"feature_maps_{scale}"] = feature_maps
            out_dict[f"prediction_map_{scale}"] = prediction_map

        return out_dict



# Файл "app\src\ml\modules\discriminator\pix2pix_discriminator.py":

import torch
from src.ml.modules.discriminator.blocks import DownBlock2d
from src.ml.modules.utils.utils import kp2gaussian
from torch import nn


class Discriminator(nn.Module):
    """Patch-based discriminator similar to Pix2Pix, with optional keypoint heatmap input."""

    def __init__(
        self,
        num_channels: int = 3,
        block_expansion: int = 64,
        num_blocks: int = 4,
        max_features: int = 512,
        sn: bool = False,
        use_kp: bool = False,
        num_kp: int = 10,
        kp_variance: float = 0.01,
        **_
    ) -> None:
        super().__init__()
        self.use_kp = use_kp
        self.kp_variance = kp_variance

        self.down_blocks = nn.ModuleList()
        for i in range(num_blocks):
            self.down_blocks.append(
                DownBlock2d(
                    in_features=(
                        num_channels + num_kp * use_kp if i == 0 else min(max_features, block_expansion * (2**i))
                    ),
                    out_features=min(max_features, block_expansion * (2 ** (i + 1))),
                    norm=(i != 0),
                    kernel_size=4,
                    pool=(i != num_blocks - 1),
                    sn=sn,
                )
            )

        conv = nn.Conv2d(self.down_blocks[-1].conv.out_channels, out_channels=1, kernel_size=1)
        self.conv = nn.utils.spectral_norm(conv) if sn else conv

    def forward(self, x: torch.Tensor, kp: dict | None = None) -> tuple[list[torch.Tensor], torch.Tensor]:
        """
        Forward pass.
        Returns:
            - List of intermediate feature maps (for multiscale loss).
            - Final prediction map.
        """
        if self.use_kp:
            heatmap = kp2gaussian(kp, x.shape[2:], self.kp_variance)
            x = torch.cat([x, heatmap], dim=1)

        feature_maps = []
        for down_block in self.down_blocks:
            x = down_block(x)
            feature_maps.append(x)

        prediction_map = self.conv(x)

        return feature_maps, prediction_map



# Файл "app\src\ml\modules\discriminator\__init__.py":

from .multi_scale_discriminator import MultiScaleDiscriminator



# Файл "app\src\ml\modules\generator\generator_full_model.py":

import torch
from src.ml.modules.generator.vgg19 import Vgg19
from src.ml.modules.utils import ImagePyramide, Transform
from src.ml.modules.utils.utils import detach_kp
from torch import nn


class GeneratorFullModel(nn.Module):
    """Merges generator-related updates into a single model to better support multi-GPU training."""

    def __init__(self, kp_extractor, generator: nn.Module, discriminator: nn.Module, train_params: dict) -> None:
        super().__init__()
        self.kp_extractor = kp_extractor
        self.generator = generator
        self.discriminator = discriminator
        self.train_params = train_params

        self.scales = train_params["scales"]
        self.disc_scales = self.discriminator.scales
        self.loss_weights = train_params["loss_weights"]

        self.pyramid = ImagePyramide(self.scales, generator.num_channels)
        if torch.cuda.is_available():
            self.pyramid = self.pyramid.cuda()

        if any(self.loss_weights["perceptual"]):
            self.vgg = Vgg19()
            if torch.cuda.is_available():
                self.vgg = self.vgg.cuda()

    def forward(self, x: dict) -> tuple[dict, dict]:
        # Keypoint extraction
        kp_source = self.kp_extractor(x["source"])
        kp_driving = self.kp_extractor(x["driving"])

        generated = self.generator(x["source"], kp_source=kp_source, kp_driving=kp_driving)
        generated.update({"kp_source": kp_source, "kp_driving": kp_driving})

        loss_values = {}

        # Pyramids
        pyramide_real = self.pyramid(x["driving"])
        pyramide_fake = self.pyramid(generated["prediction"])

        # Perceptual loss
        if any(self.loss_weights["perceptual"]):
            perceptual_loss = 0
            for scale in self.scales:
                x_vgg = self.vgg(pyramide_fake[f"prediction_{scale}"])
                y_vgg = self.vgg(pyramide_real[f"prediction_{scale}"])
                for i, weight in enumerate(self.loss_weights["perceptual"]):
                    perceptual_loss += weight * torch.abs(x_vgg[i] - y_vgg[i].detach()).mean()
            loss_values["perceptual"] = perceptual_loss

        # --- GAN + Feature Matching ---
        if self.loss_weights["generator_gan"] != 0:
            detached_kp_driving = detach_kp(kp_driving)
            disc_maps_fake = self.discriminator(pyramide_fake, kp=detached_kp_driving)
            disc_maps_real = self.discriminator(pyramide_real, kp=detached_kp_driving)

            value_total = 0
            for scale in self.disc_scales:
                key = f"prediction_map_{scale}"
                value = ((1 - disc_maps_fake[key]) ** 2).mean()
                value_total += self.loss_weights["generator_gan"] * value
            loss_values["gen_gan"] = value_total

            if any(self.loss_weights["feature_matching"]):
                fm_loss = 0
                for scale in self.disc_scales:
                    key = f"feature_maps_{scale}"
                    for i, (real_f, gen_f) in enumerate(zip(disc_maps_real[key], disc_maps_fake[key])):
                        weight = self.loss_weights["feature_matching"][i]
                        if weight != 0:
                            fm_loss += weight * torch.abs(real_f - gen_f).mean()
                loss_values["feature_matching"] = value_total

        # --- Equivariance losses ---
        eq_val_w = self.loss_weights["equivariance_value"]
        eq_jac_w = self.loss_weights["equivariance_jacobian"]

        if eq_val_w + eq_jac_w != 0:
            transform = Transform(x["driving"].shape[0], **self.train_params["transform_params"])
            transformed_frame = transform.transform_frame(x["driving"])
            transformed_kp = self.kp_extractor(transformed_frame)

            generated.update({"transformed_frame": transformed_frame, "transformed_kp": transformed_kp})

            # Value loss part
            if eq_val_w != 0:
                warped = transform.warp_coordinates(transformed_kp["value"])
                val_loss = torch.abs(kp_driving["value"] - warped).mean()
                loss_values["equivariance_value"] = eq_val_w * val_loss

            # jacobian loss part
            if eq_jac_w != 0:
                jacobian_transformed = torch.matmul(
                    transform.jacobian(transformed_kp["value"]), transformed_kp["jacobian"]
                )
                normed = torch.matmul(torch.inverse(kp_driving["jacobian"]), jacobian_transformed)
                identity = torch.eye(2).view(1, 1, 2, 2).type(normed.type())
                jac_loss = torch.abs(identity - normed).mean()
                loss_values["equivariance_jacobian"] = eq_jac_w * jac_loss

        return loss_values, generated



# Файл "app\src\ml\modules\generator\occlusion_aware_generator.py":

import torch
import torch.nn.functional as F
from src.ml.modules.blocks import (
    DownBlock2d,
    ResBlock2d,
    SameBlock2d,
    UpBlock2d,
)
from src.ml.modules.dense_motion import DenseMotionNetwork
from torch import nn


class OcclusionAwareGenerator(nn.Module):
    """
    Generator that transforms source image according to movement trajectories induced by keypoints.
    Follows the Johnson architecture.
    """

    def __init__(
        self,
        num_channels: int,
        num_kp: int,
        block_expansion: int,
        max_features: int,
        num_down_blocks: int,
        num_bottleneck_blocks: int,
        estimate_occlusion_map: bool = False,
        dense_motion_params: dict = None,
        estimate_jacobian: bool = False,
    ) -> None:
        super().__init__()

        # Dense Motion Network setup
        self.dense_motion_network = (
            DenseMotionNetwork(
                num_kp=num_kp,
                num_channels=num_channels,
                estimate_occlusion_map=estimate_occlusion_map,
                **dense_motion_params
            )
            if dense_motion_params
            else None
        )

        # First block: SameBlock2d
        self.first = SameBlock2d(num_channels, block_expansion, kernel_size=(7, 7), padding=(3, 3))

        # Downsampling blocks
        self.down_blocks = nn.ModuleList(
            [
                DownBlock2d(
                    min(max_features, block_expansion * (2**i)), min(max_features, block_expansion * (2 ** (i + 1)))
                )
                for i in range(num_down_blocks)
            ]
        )

        # Upsampling blocks
        self.up_blocks = nn.ModuleList(
            [
                UpBlock2d(
                    min(max_features, block_expansion * (2 ** (num_down_blocks - i))),
                    min(max_features, block_expansion * (2 ** (num_down_blocks - i - 1))),
                )
                for i in range(num_down_blocks)
            ]
        )

        # Bottleneck ResBlocks
        self.bottleneck = torch.nn.Sequential()
        in_features = min(max_features, block_expansion * (2**num_down_blocks))
        for i in range(num_bottleneck_blocks):
            self.bottleneck.add_module("r" + str(i), ResBlock2d(in_features, kernel_size=(3, 3), padding=(1, 1)))

        # Final output layer
        self.final = nn.Conv2d(block_expansion, num_channels, kernel_size=(7, 7), padding=(3, 3))

        # Store options for occlusion map and channels
        self.estimate_occlusion_map = estimate_occlusion_map
        self.num_channels = num_channels

    @staticmethod
    def deform_input(inp, deformation):
        _, h_old, w_old, _ = deformation.shape
        _, _, h, w = inp.shape
        if h_old != h or w_old != w:
            deformation = deformation.permute(0, 3, 1, 2)
            deformation = F.interpolate(deformation, size=(h, w), mode="bilinear")
            deformation = deformation.permute(0, 2, 3, 1)
        return F.grid_sample(inp, deformation, align_corners=True)

    def forward(self, source_image, kp_driving, kp_source) -> dict[str, torch.Tensor]:
        # Encoding (downsampling) part
        out = self.first(source_image)
        for i in range(len(self.down_blocks)):
            out = self.down_blocks[i](out)

        output_dict = {}

        # Transforming feature representation according to deformation and occlusion
        if self.dense_motion_network:
            dense_motion = self.dense_motion_network(
                source_image=source_image, kp_driving=kp_driving, kp_source=kp_source
            )
            output_dict.update(
                {
                    "mask": dense_motion["mask"],
                    "sparse_deformed": dense_motion["sparse_deformed"],
                }
            )

            if "occlusion_map" in dense_motion:
                occlusion_map = dense_motion["occlusion_map"]
                output_dict["occlusion_map"] = occlusion_map
            else:
                occlusion_map = None
            deformation = dense_motion["deformation"]
            out = self.deform_input(out, deformation)

            if occlusion_map is not None:
                if out.shape[2:] != occlusion_map.shape[2:]:
                    occlusion_map = F.interpolate(occlusion_map, size=out.shape[2:], mode="bilinear")
                out = out * occlusion_map

            output_dict["deformed"] = self.deform_input(source_image, deformation)

        # Decoding part
        out = self.bottleneck(out)
        for up_block in self.up_blocks:
            out = up_block(out)

        # Final prediction and sigmoid activation
        out = self.final(out)
        out = F.sigmoid(out)

        output_dict["prediction"] = out

        return output_dict



# Файл "app\src\ml\modules\generator\vgg19.py":

import torch
from torchvision import models


class Vgg19(torch.nn.Module):
    """VGG19 network for perceptual loss as described in Sec 3.3."""

    def __init__(self, requires_grad: bool = False) -> None:
        super().__init__()
        vgg_features = models.vgg19(pretrained=True).features

        # Define VGG slices corresponding to relu1_2, relu2_2, relu3_2, relu4_2, relu5_2
        self.slices = torch.nn.ModuleList(
            [
                vgg_features[:2],  # relu1_2
                vgg_features[2:7],  # relu2_2
                vgg_features[7:12],  # relu3_2
                vgg_features[12:21],  # relu4_2
                vgg_features[21:30],  # relu5_2
            ]
        )

        # Normalization buffers (not learnable, no grad)
        self.register_buffer("mean", torch.tensor([0.485, 0.456, 0.406]).view(1, 3, 1, 1))
        self.register_buffer("std", torch.tensor([0.229, 0.224, 0.225]).view(1, 3, 1, 1))

        if not requires_grad:
            for param in self.parameters():
                param.requires_grad = False

    def forward(self, x: torch.Tensor) -> list:
        x = (x - self.mean) / self.std
        features = []
        for slice in self.slices:
            x = slice(x)
            features.append(x)
        return features



# Файл "app\src\ml\modules\generator\__init__.py":

from .generator_full_model import GeneratorFullModel
from .occlusion_aware_generator import OcclusionAwareGenerator



# Файл "app\src\ml\modules\keypoint_detector\keypoint_detector.py":

import torch
import torch.nn.functional as F
from src.ml.modules.blocks import AntiAliasInterpolation2d, Hourglass
from src.ml.modules.utils.utils import gaussian2kp
from torch import Tensor, nn


class KPDetector(nn.Module):
    """Detects keypoints and (optionally) estimates a Jacobian matrix near each keypoint."""

    def __init__(
        self,
        block_expansion: int,
        num_kp: int,
        num_channels: int,
        max_features: int,
        num_blocks: int,
        temperature: float,
        estimate_jacobian: bool = False,
        scale_factor: float = 1.0,
        single_jacobian_map: bool = False,
        pad: str | int | tuple[int, int] = 0,
    ) -> None:
        super().__init__()
        self.temperature = temperature
        self.scale_factor = scale_factor
        self.estimate_jacobian = estimate_jacobian
        self.num_kp = num_kp

        # Backbone feature extractor
        self.predictor = Hourglass(
            block_expansion, in_features=num_channels, max_features=max_features, num_blocks=num_blocks
        )

        # Keypoint heatmap prediction
        self.kp = nn.Conv2d(in_channels=self.predictor.out_filters, out_channels=num_kp, kernel_size=7, padding=pad)

        # Optional Jacobian estimation
        if estimate_jacobian:
            self.num_jacobian_maps = 1 if single_jacobian_map else num_kp
            self.jacobian = nn.Conv2d(
                in_channels=self.predictor.out_filters,
                out_channels=4 * self.num_jacobian_maps,
                kernel_size=7,
                padding=pad,
            )
            self.jacobian.weight.data.zero_()
            self.jacobian.bias.data.copy_(torch.tensor([1, 0, 0, 1] * self.num_jacobian_maps, dtype=torch.float))
        else:
            self.jacobian = None

        self.down = AntiAliasInterpolation2d(num_channels, scale_factor) if scale_factor != 1 else None

    def forward(self, x) -> dict[str, Tensor]:
        if self.down:
            x = self.down(x)

        feature_map = self.predictor(x)
        heatmap = self.kp(feature_map)

        B, K, H, W = heatmap.shape
        heatmap_flat = heatmap.view(B, K, -1)
        heatmap = F.softmax(heatmap_flat / self.temperature, dim=2).view(B, K, H, W)

        out = gaussian2kp(heatmap)

        if self.jacobian:
            jacobian_map = self.jacobian(feature_map)  # shape: [B, 4*num_maps, H, W]
            jacobian_map = jacobian_map.view(B, self.num_jacobian_maps, 4, H, W)

            weighted = (heatmap.unsqueeze(2) * jacobian_map).view(B, K, 4, -1)
            jacobian = weighted.sum(dim=-1).view(B, K, 2, 2)
            out["jacobian"] = jacobian

        return out



# Файл "app\src\ml\modules\keypoint_detector\__init__.py":

from .keypoint_detector import KPDetector



# Файл "app\src\ml\modules\utils\image_pyramide.py":

import torch
from src.ml.modules.blocks import AntiAliasInterpolation2d
from torch import nn


class ImagePyramide(torch.nn.Module):
    """Creates an image pyramid for computing pyramidal perceptual loss.
    Args:
        scales: List of scale factors for the pyramid (e.g., [1.0, 0.5, 0.25])
        num_channels: Number of channels in input images
    """

    def __init__(self, scales: list[float], num_channels: int) -> None:
        super().__init__()

        # Validate input scales
        if not scales or any(scale <= 0 for scale in scales):
            raise ValueError("Scales must be positive values")

        # Create downsampling modules
        self.downs = nn.ModuleDict(
            {f"scale_{scale}": AntiAliasInterpolation2d(num_channels, scale) for scale in scales}
        )

        # Cache scale names for faster forward pass
        self.scale_names = list(self.downs.keys())
        self.output_keys = [f'prediction_{scale.split("_")[1]}' for scale in self.scale_names]

    def forward(self, x: torch.Tensor) -> dict[str, torch.Tensor]:
        """Process input image through the pyramid.
        Returns:
            Dictionary with keys like 'prediction_1.0', 'prediction_0.5' etc.
        """
        return {key: down_module(x) for key, down_module in zip(self.output_keys, self.downs.values())}



# Файл "app\src\ml\modules\utils\transform.py":

import torch
import torch.nn.functional as F
from src.ml.modules.utils.utils import make_coordinate_grid
from torch.autograd import grad


class Transform:
    """Thin Plate Spline (TPS) transformation for equivariance constraints with both affine and non-linear components.
    Args:
        bs: Batch size
        sigma_affine: Standard deviation for affine transformation parameters
        sigma_tps: Standard deviation for TPS control point parameters (optional)
        points_tps: Number of control points along each axis (optional)
    """

    def __init__(self, bs: int, **kwargs) -> None:
        self.bs = bs

        # Initialize random affine transformation parameters
        noise = torch.normal(mean=0, std=kwargs["sigma_affine"] * torch.ones([bs, 2, 3]))
        self.theta = noise + torch.eye(2, 3).view(1, 2, 3)

        # Initialize TPS transformation if parameters provided
        self.tps = ("sigma_tps" in kwargs) and ("points_tps" in kwargs)
        if self.tps:
            self.control_points = make_coordinate_grid((kwargs["points_tps"], kwargs["points_tps"]), type=noise.type())
            self.control_points = self.control_points.unsqueeze(0)
            self.control_params = torch.normal(
                mean=0, std=kwargs["sigma_tps"] * torch.ones([bs, 1, kwargs["points_tps"] ** 2])
            )

    def transform_frame(self, frame: torch.Tensor) -> torch.Tensor:
        """Apply transformation to input frame.
        Args:
            frame: Input tensor of shape [bs, C, H, W]
        Returns:
            Transformed frame of same shape
        """
        grid = make_coordinate_grid(frame.shape[2:], type=frame.type()).unsqueeze(0)
        grid = grid.view(1, frame.shape[2] * frame.shape[3], 2)
        warped_grid = self.warp_coordinates(grid).view(self.bs, *frame.shape[2:], 2)
        return F.grid_sample(frame, warped_grid, padding_mode="reflection", align_corners=True)

    def warp_coordinates(self, coordinates: torch.Tensor) -> torch.Tensor:
        """Apply both affine and TPS transformations to coordinates.
        Args:
            coordinates: Tensor of shape [bs, N, 2]
        Returns:
            Transformed coordinates of same shape
        """
        # Apply affine transformation
        transformed = self._apply_affine_transform(coordinates)

        # Apply TPS transformation if enabled
        if self.tps:
            transformed = self._apply_tps_transform(transformed, coordinates)

        return transformed

    def _apply_affine_transform(self, coordinates: torch.Tensor) -> torch.Tensor:
        """Apply affine transformation to coordinates."""
        # Efficient affine transform using einsum
        return torch.einsum(
            "bni,bij->bnj",
            torch.cat([coordinates, torch.ones_like(coordinates[..., :1])], dim=-1),
            self.theta.type_as(coordinates),
        )

    def _apply_tps_transform(self, transformed: torch.Tensor, coordinates: torch.Tensor) -> torch.Tensor:
        """Apply Thin Plate Spline non-linear transformation."""
        # Calculate distances between coordinates and control points
        diff = coordinates.unsqueeze(2) - self.control_points.type_as(coordinates).view(1, 1, -1, 2)
        distances = torch.norm(diff, p=1, dim=-1)  # L1 distance

        # Compute TPS radial basis function
        result = distances**2 * torch.log(distances + 1e-6)
        result = (result * self.control_params.type_as(coordinates)).sum(dim=2)

        return transformed + result.unsqueeze(-1)

    def jacobian(self, coordinates: torch.Tensor) -> torch.Tensor:
        new_coordinates = self.warp_coordinates(coordinates)
        grad_x = grad(new_coordinates[..., 0].sum(), coordinates, create_graph=True)
        grad_y = grad(new_coordinates[..., 1].sum(), coordinates, create_graph=True)
        jacobian = torch.cat([grad_x[0].unsqueeze(-2), grad_y[0].unsqueeze(-2)], dim=-2)
        return jacobian



# Файл "app\src\ml\modules\utils\utils.py":

import torch


def kp2gaussian(kp: dict, spatial_size: tuple[int, int], kp_variance: float) -> torch.Tensor:
    """Converts keypoints to Gaussian heatmaps with optimized tensor operations."""
    mean = kp["value"]
    coordinate_grid = make_coordinate_grid(spatial_size, mean.type()).view(1, 1, *spatial_size, 2)

    # Expand dimensions for broadcasting
    mean = mean.view(*mean.shape[:2], 1, 1, 2)
    diff = coordinate_grid - mean
    return torch.exp(-0.5 * (diff.pow(2).sum(-1) / kp_variance))


def gaussian2kp(heatmap):
    """Extract the mean and from a heatmap."""
    shape = heatmap.shape
    heatmap = heatmap.unsqueeze(-1)
    grid = make_coordinate_grid(shape[2:], heatmap.type()).unsqueeze_(0).unsqueeze_(0)
    value = (heatmap * grid).sum(dim=(2, 3))
    kp = {"value": value}
    return kp


def detach_kp(kp):
    return {key: value.detach() for key, value in kp.items()}


def make_coordinate_grid(spatial_size: tuple[int, int], type) -> torch.Tensor:
    """Creates normalized grid coordinates with modern PyTorch features."""
    h, w = spatial_size
    x = torch.arange(w).type(type)
    y = torch.arange(h).type(type)

    x = 2 * (x / (w - 1)) - 1
    y = 2 * (y / (h - 1)) - 1

    yy = y.view(-1, 1).repeat(1, w)
    xx = x.view(1, -1).repeat(h, 1)

    meshed = torch.cat([xx.unsqueeze_(2), yy.unsqueeze_(2)], 2)

    return meshed



# Файл "app\src\ml\modules\utils\__init__.py":

from .image_pyramide import ImagePyramide
from .transform import Transform



# Файл "app\src\ml\runners\animation.py":

from src.ml.datasets import FramesDataset
from src.ml.runners.base import BaseRunner
from src.ml.services.animation import AnimationService


class AnimationRunner(BaseRunner):
    def __init__(self, args, log):
        super().__init__(args, log)
        self.animation_service = AnimationService()

    def run(self):
        dataset = FramesDataset(is_train=False, **self.config["dataset_params"])
        self.log.info("Animation started...")
        self.animation_service.animate(
            self.config, self.generator, self.kp_detector, self.args.checkpoint, self.log_dir, dataset
        )



# Файл "app\src\ml\runners\base.py":

from abc import ABC, abstractmethod
from argparse import Namespace
from logging import Logger

from src.ml.services.model import ModelService


class BaseRunner(ABC):
    def __init__(self, args: Namespace, log: Logger):
        self.args = args
        self.log = log
        self.device_ids = args.device_ids
        self.verbose = args.verbose

        model_service = ModelService(args.configs, args.checkpoint, args.log_dir, cpu=args.cpu)

        self.config = model_service.config
        self.log_dir = model_service.log_dir

        self.generator, self.discriminator, self.kp_detector = model_service.init_training_models(self.device_ids)

    @abstractmethod
    def run(self):
        pass



# Файл "app\src\ml\runners\reconstruction.py":

from src.ml.datasets import FramesDataset
from src.ml.runners.base import BaseRunner
from src.ml.services.reconstruction import ReconstructionService


class ReconstructionRunner(BaseRunner):
    def run(self):
        dataset = FramesDataset(is_train=False, **self.config["dataset_params"])
        self.log.info("Reconstruction started...")
        ReconstructionService.reconstruction(
            self.config, self.generator, self.kp_detector, self.args.checkpoint, self.log_dir, dataset
        )



# Файл "app\src\ml\runners\training.py":

from src.ml.datasets import FramesDataset
from src.ml.runners.base import BaseRunner
from src.ml.services.training import TrainingService


class TrainingRunner(BaseRunner):
    def run(self):
        dataset = FramesDataset(is_train=True, **self.config["dataset_params"])
        self.log.info("Training started...")
        TrainingService.train(
            self.config,
            self.generator,
            self.discriminator,
            self.kp_detector,
            self.args.checkpoint,
            self.log_dir,
            dataset,
            self.device_ids,
        )



# Файл "app\src\ml\runners\__init__.py":

from .animation import AnimationRunner
from .reconstruction import ReconstructionRunner
from .training import TrainingRunner



# Файл "app\src\ml\services\animation.py":

import os

import numpy as np
import torch
from scipy.spatial import ConvexHull
from src.ml.datasets import PairedDataset
from src.ml.datasets.replicate import DataParallelWithCallback
from src.ml.services.logging import LoggingService
from src.ml.services.visualization import VisualizationService
from torch.utils.data import DataLoader
from tqdm import tqdm


class AnimationService:
    """Service for generating animations using keypoint detection and image generation."""

    @classmethod
    def make_animation(
        cls,
        source_image: np.ndarray,
        driving_video: list[np.ndarray],
        generator: torch.nn.Module,
        kp_detector: torch.nn.Module,
        relative: bool = True,
        adapt_movement_scale: bool = True,
        cpu: bool = False,
    ) -> list[np.ndarray]:
        """
        Generate fomm from source image and driving video.
        Args:
            source_image: Source image (H, W, C)
            driving_video: Driving video frames (T, H, W, C)
            generator: Image generator model
            kp_detector: Keypoint detector model
            relative: Use relative movement
            adapt_movement_scale: Adapt movement scale
            cpu: Force CPU execution
        Returns:
            List of predicted frames
        """
        device = torch.device("cpu") if cpu else torch.device("cuda")

        with torch.no_grad():
            # Convert inputs to tensors
            source = cls._image_to_tensor(source_image).to(device)
            driving = cls._video_to_tensor(driving_video).to(device)

            # Get keypoints
            kp_source = kp_detector(source)
            kp_driving_initial = kp_detector(driving[:, :, 0])

            # Process each frame
            predictions = []
            for frame_idx in tqdm(range(driving.shape[2]), desc="Generating fomm"):
                driving_frame = driving[:, :, frame_idx]
                kp_driving = kp_detector(driving_frame)

                kp_norm = cls.normalize_kp(
                    kp_source=kp_source,
                    kp_driving=kp_driving,
                    kp_driving_initial=kp_driving_initial,
                    use_relative_movement=relative,
                    use_relative_jacobian=relative,
                    adapt_movement_scale=adapt_movement_scale,
                )

                out = generator(source, kp_source=kp_source, kp_driving=kp_norm)
                predictions.append(cls._tensor_to_image(out["prediction"]))

        return predictions

    @staticmethod
    def _image_to_tensor(image: np.ndarray) -> torch.Tensor:
        """Convert numpy image to tensor."""
        return torch.from_numpy(image[np.newaxis].astype(np.float32)).permute(0, 3, 1, 2)

    @staticmethod
    def _tensor_to_image(tensor: torch.Tensor) -> np.ndarray:
        """Convert tensor to numpy image."""
        return np.transpose(tensor.data.cpu().numpy(), [0, 2, 3, 1])[0]

    @staticmethod
    def _video_to_tensor(video: list[np.ndarray]) -> torch.Tensor:
        """Convert numpy video to tensor."""
        return torch.from_numpy(np.array(video)[np.newaxis].astype(np.float32)).permute(0, 4, 1, 2, 3)

    @staticmethod
    def animate(
        config: dict,
        generator: torch.nn.Module,
        kp_detector: torch.nn.Module,
        checkpoint: str,
        log_dir: str,
        dataset: PairedDataset,
        imageio=None,
    ) -> None:
        """
        Main fomm pipeline with visualization and saving.
        Args:
            config: Configuration dictionary
            generator: Image generator model
            kp_detector: Keypoint detector model
            checkpoint: Path to model checkpoint
            log_dir: Directory to save outputs
            dataset: Dataset for fomm
            imageio: ImageIO instance for saving
        """
        # Setup directories
        log_dir = os.path.join(log_dir, "services")
        png_dir = os.path.join(log_dir, "png")
        os.makedirs(png_dir, exist_ok=True)

        # Load checkpoint
        if not checkpoint:
            raise ValueError("Checkpoint must be specified for fomm mode")
        LoggingService.load_cpk(checkpoint, generator=generator, kp_detector=kp_detector)

        # Prepare models
        if torch.cuda.is_available():
            generator = DataParallelWithCallback(generator)
            kp_detector = DataParallelWithCallback(kp_detector)

        generator.eval()
        kp_detector.eval()

        # Create dataset and dataloader
        animate_params = config["animate_params"]
        dataset = PairedDataset(initial_dataset=dataset, number_of_pairs=animate_params["num_pairs"])
        dataloader = DataLoader(dataset, batch_size=1, shuffle=False, num_workers=2)

        # Initialize visualizer
        visualizer = VisualizationService(**config["visualizer_params"])

        # Process each pair
        for x in tqdm(dataloader, desc="Animating dataset"):
            with torch.no_grad():
                predictions, visualizations = [], []
                driving_video = x["driving_video"]
                source_frame = x["source_video"][:, :, 0, :, :]

                # Get keypoints
                kp_source = kp_detector(source_frame)
                kp_driving_initial = kp_detector(driving_video[:, :, 0])

                # Process each frame
                for frame_idx in range(driving_video.shape[2]):
                    driving_frame = driving_video[:, :, frame_idx]
                    kp_driving = kp_detector(driving_frame)

                    kp_norm = AnimationService.normalize_kp(
                        kp_source=kp_source,
                        kp_driving=kp_driving,
                        kp_driving_initial=kp_driving_initial,
                        **animate_params["normalization_params"],
                    )

                    out = generator(source_frame, kp_source=kp_source, kp_driving=kp_norm)

                    # Prepare outputs
                    out.update({"kp_driving": kp_driving, "kp_source": kp_source, "kp_norm": kp_norm})
                    del out["sparse_deformed"]

                    # Save results
                    predictions.append(AnimationService._tensor_to_image(out["prediction"]))
                    visualizations.append(visualizer.visualize(source=source_frame, driving=driving_frame, out=out))

                # Save outputs
                result_name = f"{x['driving_name'][0]}-{x['source_name'][0]}"
                predictions = np.concatenate(predictions, axis=1)

                imageio.imsave(
                    os.path.join(png_dir, f"{result_name}.png"),
                    (255 * predictions).astype(np.uint8),
                )

                imageio.mimsave(
                    os.path.join(log_dir, f"{result_name}{animate_params['format']}"),
                    visualizations,
                )

    @classmethod
    def normalize_kp(
        cls,
        kp_source: dict[str, torch.Tensor],
        kp_driving: dict[str, torch.Tensor],
        kp_driving_initial: dict[str, torch.Tensor],
        adapt_movement_scale: bool = False,
        use_relative_movement: bool = False,
        use_relative_jacobian: bool = False,
    ) -> dict[str, torch.Tensor]:
        """
        Normalize keypoints between source and driving frames.
        Args:
            kp_source: Source keypoints
            kp_driving: Driving keypoints
            kp_driving_initial: Initial driving keypoints
            adapt_movement_scale: Adjust for scale differences
            use_relative_movement: Use relative movement
            use_relative_jacobian: Use relative jacobian
        Returns:
            Normalized keypoints
        """
        kp_new = kp_driving.copy()

        if adapt_movement_scale:
            scale = cls._calculate_movement_scale(kp_source, kp_driving_initial)
        else:
            scale = 1.0

        if use_relative_movement:
            kp_value_diff = (kp_driving["value"] - kp_driving_initial["value"]) * scale
            kp_new["value"] = kp_value_diff + kp_source["value"]

            if use_relative_jacobian:
                jacobian_diff = torch.matmul(kp_driving["jacobian"], torch.inverse(kp_driving_initial["jacobian"]))
                kp_new["jacobian"] = torch.matmul(jacobian_diff, kp_source["jacobian"])

        return kp_new

    @staticmethod
    def _calculate_movement_scale(
        kp_source: dict[str, torch.Tensor], kp_driving_initial: dict[str, torch.Tensor]
    ) -> float:
        """Calculate movement scale based on convex hull areas."""
        source_area = ConvexHull(kp_source["value"][0].cpu().numpy()).volume
        driving_area = ConvexHull(kp_driving_initial["value"][0].cpu().numpy()).volume
        return np.sqrt(source_area) / np.sqrt(driving_area)



# Файл "app\src\ml\services\logging.py":

import collections
import logging
import os
import sys

import imageio
import numpy as np
import torch
from src.ml.services.visualization import VisualizationService


class LoggingService:
    def __init__(
        self,
        log_dir: str,
        log_file_name: str = "log.txt",
        checkpoint_freq: int = 100,
        visualizer_params=None,
        zfill_num: int = 8,
    ) -> None:
        self.loss_list = []
        self.cpk_dir = log_dir
        self.visualizations_dir = os.path.join(log_dir, "train-vis")
        os.makedirs(self.visualizations_dir, exist_ok=True)
        self.log_file = open(os.path.join(log_dir, log_file_name), "a")
        self.zfill_num = zfill_num
        self.visualizer = VisualizationService(**visualizer_params)
        self.checkpoint_freq = checkpoint_freq
        self.epoch = 0
        self.best_loss = float("inf")
        self.names = None
        self.models = None

    def log_scores(self, loss_names) -> None:
        loss_mean = np.array(self.loss_list).mean(axis=0)

        loss_string = "; ".join(["%s - %.5f" % (name, value) for name, value in zip(loss_names, loss_mean)])
        loss_string = str(self.epoch).zfill(self.zfill_num) + ") " + loss_string

        print(loss_string, file=self.log_file)
        self.loss_list = []
        self.log_file.flush()

    def visualize_rec(self, inp, out) -> None:
        image = self.visualizer.visualize(inp["driving"], inp["source"], out)
        imageio.imsave(
            os.path.join(self.visualizations_dir, "%s-rec.png" % str(self.epoch).zfill(self.zfill_num)), image
        )

    def save_cpk(self, emergent: bool = False) -> None:
        cpk = {k: v.state_dict() for k, v in self.models.items()}
        cpk["epoch"] = self.epoch
        cpk_path = os.path.join(self.cpk_dir, "%s-checkpoint.pth.tar" % str(self.epoch).zfill(self.zfill_num))
        if not (os.path.exists(cpk_path) and emergent):
            torch.save(cpk, cpk_path)

    @staticmethod
    def load_cpk(
        checkpoint_path: str,
        generator=None,
        discriminator=None,
        kp_detector=None,
        optimizer_generator=None,
        optimizer_discriminator=None,
        optimizer_kp_detector=None,
    ):
        log = LoggingService.setup_logger(__name__)
        checkpoint = torch.load(checkpoint_path)
        if generator:
            generator.load_state_dict(checkpoint["generator"])
        if kp_detector:
            kp_detector.load_state_dict(checkpoint["kp_detector"])
        if discriminator:
            try:
                discriminator.load_state_dict(checkpoint["discriminator"])
            except:
                log.error("No discriminator in the state-dict. Dicriminator will be randomly initialized")
        if optimizer_generator:
            optimizer_generator.load_state_dict(checkpoint["optimizer_generator"])
        if optimizer_discriminator:
            try:
                optimizer_discriminator.load_state_dict(checkpoint["optimizer_discriminator"])
            except RuntimeError:
                log.error("No discriminator optimizer in the state-dict. Optimizer will be not initialized")
        if optimizer_kp_detector:
            optimizer_kp_detector.load_state_dict(checkpoint["optimizer_kp_detector"])

        return checkpoint["epoch"]

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        if "models" in self.__dict__:
            self.save_cpk()
        self.log_file.close()

    def log_iter(self, losses) -> None:
        losses = collections.OrderedDict(losses.items())
        if self.names is None:
            self.names = list(losses.keys())
        self.loss_list.append(list(losses.values()))

    def log_epoch(self, epoch, models, inp, out) -> None:
        self.epoch = epoch
        self.models = models
        if (self.epoch + 1) % self.checkpoint_freq == 0:
            self.save_cpk()
        self.log_scores(self.names)
        self.visualize_rec(inp, out)

    @staticmethod
    def setup_logger(name: str) -> logging.Logger:
        logger = logging.getLogger(name)
        logger.setLevel(logging.DEBUG)
        formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S"
        )
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)
        return logger



# Файл "app\src\ml\services\model.py":

import os
from shutil import copy
from time import gmtime, strftime

import torch
import yaml
from src.ml.datasets.replicate import DataParallelWithCallback
from src.ml.modules.discriminator import MultiScaleDiscriminator
from src.ml.modules.generator import OcclusionAwareGenerator
from src.ml.modules.keypoint_detector import KPDetector


class ModelService:
    def __init__(
        self,
        config_path: str,
        checkpoint_path: str = None,
        log_dir: str = "log",
        cpu: bool = False,
        verbose: bool = False,
    ) -> None:
        self.config_path = config_path
        self.checkpoint_path = checkpoint_path
        self.log_dir = log_dir
        self.cpu = cpu
        self.verbose = verbose
        self.config = self._load_config()
        self.log_dir = self._prepare_log_dir()
        self.device = torch.device("cpu" if cpu else "cuda:0")

    def _load_config(self):
        with open(self.config_path) as f:
            return yaml.safe_load(f)

    def _prepare_log_dir(self):
        if self.checkpoint_path:
            return os.path.join(*os.path.split(self.checkpoint_path)[:-1])
        else:
            log_dir = os.path.join(self.log_dir, os.path.basename(self.config_path).split(".")[0])
            log_dir += " " + strftime("%d_%m_%y_%H.%M.%S", gmtime())
            os.makedirs(log_dir, exist_ok=True)

            config_copy_path = os.path.join(log_dir, os.path.basename(self.config_path))
            if not os.path.exists(config_copy_path):
                copy(self.config_path, config_copy_path)

            return log_dir

    def init_training_models(self, device_ids: list) -> tuple[torch.nn.Module, torch.nn.Module, torch.nn.Module]:
        generator = OcclusionAwareGenerator(
            **self.config["model_params"]["generator_params"], **self.config["model_params"]["common_params"]
        )
        discriminator = MultiScaleDiscriminator(
            **self.config["model_params"]["discriminator_params"], **self.config["model_params"]["common_params"]
        )
        kp_detector = KPDetector(
            **self.config["model_params"]["kp_detector_params"], **self.config["model_params"]["common_params"]
        )

        if torch.cuda.is_available() and not self.cpu:
            generator.to(device_ids[0])
            discriminator.to(device_ids[0])
            kp_detector.to(device_ids[0])

        if self.verbose:
            print(generator)
            print(discriminator)
            print(kp_detector)

        return generator, discriminator, kp_detector

    def load_eval_models(self):
        generator = OcclusionAwareGenerator(
            **self.config["model_params"]["generator_params"],
            **self.config["model_params"]["common_params"],
        )

        kp_detector = KPDetector(
            **self.config["model_params"]["kp_detector_params"],
            **self.config["model_params"]["common_params"],
        )

        if not self.cpu:
            generator.cuda()
            kp_detector.cuda()

        checkpoint = torch.load(self.checkpoint_path, map_location=self.device)
        generator.load_state_dict(checkpoint["generator"])
        kp_detector.load_state_dict(checkpoint["kp_detector"])

        if not self.cpu:
            generator = DataParallelWithCallback(generator)
            kp_detector = DataParallelWithCallback(kp_detector)

        generator.eval()
        kp_detector.eval()

        return generator, kp_detector



# Файл "app\src\ml\services\reconstruction.py":

import os

import cv2
import numpy as np
import torch
from src.ml.datasets.replicate import DataParallelWithCallback
from src.ml.services.logging import LoggingService
from src.ml.services.visualization import VisualizationService
from torch.utils.data import DataLoader
from tqdm import tqdm

log = LoggingService.setup_logger(__name__)


class ReconstructionService:
    @staticmethod
    def reconstruction(config: dict, generator, kp_detector, checkpoint: str, log_dir: str, dataset) -> None:
        png_dir = os.path.join(log_dir, "reconstruction/png")
        log_dir = os.path.join(log_dir, "reconstruction")

        if not checkpoint:
            raise AttributeError("Checkpoint should be specified for mode='reconstruction'.")
        LoggingService.load_cpk(checkpoint, generator=generator, kp_detector=kp_detector)

        dataloader = DataLoader(dataset, batch_size=1, shuffle=False, num_workers=1)

        os.makedirs(log_dir, exist_ok=True)
        os.makedirs(png_dir, exist_ok=True)

        loss_list = []
        if torch.cuda.is_available():
            generator = DataParallelWithCallback(generator)
            kp_detector = DataParallelWithCallback(kp_detector)

        generator.eval()
        kp_detector.eval()

        for it, x in tqdm(enumerate(dataloader)):
            if config["reconstruction_params"]["num_videos"] is not None:
                if it > config["reconstruction_params"]["num_videos"]:
                    break
            with torch.no_grad():
                predictions = []
                visualizations = []
                if torch.cuda.is_available():
                    x["video"] = x["video"].cuda()

                kp_source = kp_detector(x["video"][:, :, 0])
                for frame_idx in range(x["video"].shape[2]):
                    source = x["video"][:, :, 0]
                    driving = x["video"][:, :, frame_idx]
                    kp_driving = kp_detector(driving)
                    out = generator(source, kp_source=kp_source, kp_driving=kp_driving)
                    out["kp_source"] = kp_source
                    out["kp_driving"] = kp_driving
                    del out["sparse_deformed"]
                    predictions.append(np.transpose(out["prediction"].data.cpu().numpy(), [0, 2, 3, 1])[0])

                    visualization = VisualizationService(**config["visualizer_params"]).visualize(
                        source=source, driving=driving, out=out
                    )
                    visualizations.append(visualization)

                    loss_list.append(torch.abs(out["prediction"] - driving).mean().cpu().numpy())

                predictions = np.concatenate(predictions, axis=1)

                # Save concatenated predictions as PNG using OpenCV
                image = (255 * predictions).astype(np.uint8)
                image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
                cv2.imwrite(os.path.join(png_dir, x["name"][0] + ".png"), image)

                image_name = x["name"][0] + config["reconstruction_params"]["format"]

                # Save visualizations as video using OpenCV
                if visualizations:
                    fps = config["reconstruction_params"].get("fps", 30)
                    frame_height, frame_width = visualizations[0].shape[:2]

                    # Determine FourCC based on file extension
                    file_ext = config["reconstruction_params"]["format"].lower()
                    fourcc = {".mp4": "mp4v", ".avi": "XVID", ".mov": "MJPG"}.get(file_ext, "mp4v")
                    fourcc_code = cv2.VideoWriter_fourcc(*fourcc)
                    video_path = os.path.join(log_dir, image_name)
                    video_writer = cv2.VideoWriter(video_path, fourcc_code, fps, (frame_width, frame_height))
                    for frame in visualizations:
                        frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                        video_writer.write(frame_bgr)
                    video_writer.release()

        log.info("Reconstruction loss:", np.mean(loss_list))



# Файл "app\src\ml\services\training.py":

import torch
from src.ml.datasets.dataset_repeater import DatasetRepeater
from src.ml.datasets.replicate import DataParallelWithCallback
from src.ml.modules.discriminator.discriminator_full_model import (
    DiscriminatorFullModel,
)
from src.ml.modules.generator import GeneratorFullModel
from src.ml.services.logging import LoggingService
from torch.optim.lr_scheduler import MultiStepLR
from torch.utils.data import DataLoader
from tqdm import trange


class TrainingService:
    @staticmethod
    def train(
        config: dict, generator, discriminator, kp_detector, checkpoint: str, log_dir: str, dataset, device_ids: list
    ) -> None:
        train_params = config["train_params"]

        optimizer_generator = torch.optim.Adam(
            generator.parameters(), lr=train_params["lr_generator"], betas=(0.5, 0.999)
        )
        optimizer_discriminator = torch.optim.Adam(
            discriminator.parameters(), lr=train_params["lr_discriminator"], betas=(0.5, 0.999)
        )
        optimizer_kp_detector = torch.optim.Adam(
            kp_detector.parameters(), lr=train_params["lr_kp_detector"], betas=(0.5, 0.999)
        )

        if checkpoint:
            start_epoch = LoggingService.load_cpk(
                checkpoint,
                generator,
                discriminator,
                kp_detector,
                optimizer_generator,
                optimizer_discriminator,
                None if train_params["lr_kp_detector"] == 0 else optimizer_kp_detector,
            )
        else:
            start_epoch = 0

        scheduler_generator = MultiStepLR(
            optimizer_generator, train_params["epoch_milestones"], gamma=0.1, last_epoch=start_epoch - 1
        )
        scheduler_discriminator = MultiStepLR(
            optimizer_discriminator, train_params["epoch_milestones"], gamma=0.1, last_epoch=start_epoch - 1
        )
        scheduler_kp_detector = MultiStepLR(
            optimizer_kp_detector,
            train_params["epoch_milestones"],
            gamma=0.1,
            last_epoch=-1 + start_epoch * (train_params["lr_kp_detector"] != 0),
        )

        if "num_repeats" in train_params or train_params["num_repeats"] != 1:
            dataset = DatasetRepeater(dataset, train_params["num_repeats"])
        dataloader = DataLoader(
            dataset, batch_size=train_params["batch_size"], shuffle=True, num_workers=6, drop_last=True
        )

        generator_full = GeneratorFullModel(kp_detector, generator, discriminator, train_params)
        discriminator_full = DiscriminatorFullModel(kp_detector, generator, discriminator, train_params)

        if torch.cuda.is_available():
            generator_full = DataParallelWithCallback(generator_full, device_ids=device_ids)
            discriminator_full = DataParallelWithCallback(discriminator_full, device_ids=device_ids)

        with LoggingService(
            log_dir=log_dir,
            visualizer_params=config["visualizer_params"],
            checkpoint_freq=train_params["checkpoint_freq"],
        ) as logger:
            for epoch in trange(start_epoch, train_params["num_epochs"]):
                for x in dataloader:
                    losses_generator, generated = generator_full(x)

                    loss_values = [val.mean() for val in losses_generator.values()]
                    loss = sum(loss_values)

                    loss.backward()
                    optimizer_generator.step()
                    optimizer_generator.zero_grad()
                    optimizer_kp_detector.step()
                    optimizer_kp_detector.zero_grad()

                    if train_params["loss_weights"]["generator_gan"] != 0:
                        optimizer_discriminator.zero_grad()
                        losses_discriminator = discriminator_full(x, generated)
                        loss_values = [val.mean() for val in losses_discriminator.values()]
                        loss = sum(loss_values)

                        loss.backward()
                        optimizer_discriminator.step()
                        optimizer_discriminator.zero_grad()
                    else:
                        losses_discriminator = {}

                    losses_generator.update(losses_discriminator)
                    losses = {key: value.mean().detach().data.cpu().numpy() for key, value in losses_generator.items()}
                    logger.log_iter(losses=losses)

                scheduler_generator.step()
                scheduler_discriminator.step()
                scheduler_kp_detector.step()

                logger.log_epoch(
                    epoch,
                    {
                        "generator": generator,
                        "discriminator": discriminator,
                        "kp_detector": kp_detector,
                        "optimizer_generator": optimizer_generator,
                        "optimizer_discriminator": optimizer_discriminator,
                        "optimizer_kp_detector": optimizer_kp_detector,
                    },
                    inp=x,
                    out=generated,
                )



# Файл "app\src\ml\services\utils.py":

import warnings

import cv2
import numpy as np
from scipy.spatial import ConvexHull
from skimage.transform import resize


def find_best_frame(source_image: np.ndarray, driving_video: list[np.ndarray], cpu: bool = False) -> int:
    """
    Find the driving frame with most similar facial landmarks to source image.
    Args:
        source_image: Source image (H, W, C)
        driving_video: List of driving frames
        cpu: Force CPU execution
    Returns:
        Index of best matching frame
    """
    import face_alignment  # Lazy import to reduce dependencies

    def normalize_kp(kp: np.ndarray) -> np.ndarray:
        """Normalize keypoints by centering and scaling by face area."""
        kp = kp - kp.mean(axis=0, keepdims=True)
        area = np.sqrt(ConvexHull(kp[:, :2]).volume)
        return kp / area

    # Initialize face alignment
    device = "cpu" if cpu else "cuda"
    fa = face_alignment.FaceAlignment(face_alignment.LandmarksType._2D, flip_input=True, device=device)

    # Process source landmarks
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")  # Suppress skimage resize warnings
        kp_source = fa.get_landmarks((255 * source_image).astype(np.uint8))

    if not kp_source:
        raise ValueError("No faces detected in source image")
    kp_source = normalize_kp(kp_source[0])

    # Find best matching frame
    min_norm = float("inf")
    best_frame = 0

    for i, frame in enumerate(driving_video):
        kp_driving = fa.get_landmarks((255 * frame).astype(np.uint8))
        if not kp_driving:
            continue

        kp_driving = normalize_kp(kp_driving[0])
        current_norm = np.sum((kp_source - kp_driving) ** 2)

        if current_norm < min_norm:
            min_norm = current_norm
            best_frame = i

    return best_frame


def preprocess_image(image_path: str, target_size: tuple[int, int] = (256, 256), normalize: bool = True) -> np.ndarray:
    """
    Load and preprocess an image.
    Args:
        image_path: Path to image file
        target_size: Target dimensions (H, W)
        normalize: Scale to [0,1] range
    Returns:
        Processed image array
    """
    # Read image
    image = cv2.imread(image_path)
    if image is None:
        raise FileNotFoundError(f"Could not load image at {image_path}")

    # Convert color space
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # Resize with antialiasing
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        image = resize(image, target_size, preserve_range=False, anti_aliasing=True)

    # Ensure 3 channels and normalize
    image = image[..., :3]
    if normalize:
        image = np.clip(image, 0, 1).astype(np.float32)

    return image


def load_video(
    video_path: str, target_size: tuple[int, int] = (256, 256), max_frames: int | None = None
) -> tuple[list[np.ndarray], float]:
    """
    Load and preprocess video frames.
    Args:
        video_path: Path to video file
        target_size: Target dimensions (H, W)
        max_frames: Maximum number of frames to load
    Returns:
        Tuple of (frames, fps)
    """
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        raise FileNotFoundError(f"Could not open video at {video_path}")

    fps = cap.get(cv2.CAP_PROP_FPS)
    frames = []

    while True:
        ret, frame = cap.read()
        if not ret or (max_frames and len(frames) >= max_frames):
            break

        # Convert and resize
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            frame = resize(frame, target_size, preserve_range=False, anti_aliasing=True)
        frames.append(frame[..., :3])

    cap.release()
    return frames, fps



# Файл "app\src\ml\services\video_animation.py":

from pathlib import Path

import cv2
import numpy as np
from skimage.util import img_as_ubyte
from src.ml.services.animation import AnimationService
from src.ml.services.logging import LoggingService
from src.ml.services.model import ModelService
from src.ml.services.utils import find_best_frame, load_video, preprocess_image


class VideoAnimationService:
    """Service for generating animated videos from source images and driving videos."""

    def __init__(
        self,
        config_path: str,
        checkpoint_path: str,
        source_image_path: str,
        driving_video_path: str,
        result_video_path: str,
        relative: bool = False,
        adapt_scale: bool = False,
        find_best: bool = False,
        best_frame: int | None = None,
        cpu: bool = False,
    ) -> None:
        """Initialize video fomm service.
        Args:
            config_path: Path to model configuration
            checkpoint_path: Path to model checkpoint
            source_image_path: Path to source image
            driving_video_path: Path to driving video
            result_video_path: Output video path
            relative: Use relative keypoint movement
            adapt_scale: Adapt movement scale
            find_best: Find best frame automatically
            best_frame: Specify best frame index
            cpu: Force CPU execution
        """
        self.log = LoggingService.setup_logger(__name__)
        self._validate_paths(source_image_path, driving_video_path)

        self.config_path = config_path
        self.checkpoint_path = checkpoint_path
        self.source_image_path = source_image_path
        self.driving_video_path = driving_video_path
        self.result_video_path = result_video_path
        self.relative = relative
        self.adapt_scale = adapt_scale
        self.find_best = find_best
        self.best_frame = best_frame
        self.cpu = cpu

        # Initialize models
        model_service = ModelService(config_path, checkpoint_path, cpu=cpu)
        self.generator, self.kp_detector = model_service.load_eval_models()
        self._log_init()

    @staticmethod
    def _validate_paths(*paths: str) -> None:
        """Validate input file paths exist."""
        for path in paths:
            if not Path(path).exists():
                raise FileNotFoundError(f"Path does not exist: {path}")

    def _log_init(self) -> None:
        """Log initialization parameters."""
        self.log.info(f"Initialized VideoAnimationService with:")
        self.log.info(f"Source: {self.source_image_path}")
        self.log.info(f"Driving: {self.driving_video_path}")
        self.log.info(f"Output: {self.result_video_path}")
        self.log.info(f"Settings: relative={self.relative}, adapt_scale={self.adapt_scale}")

    def run(self) -> None:
        """Execute the full fomm pipeline."""
        try:
            # Load and preprocess media
            source_image = preprocess_image(self.source_image_path)
            driving_video, fps = load_video(self.driving_video_path)

            # Generate animations
            predictions = self._generate_animations(source_image, driving_video)

            # Save results
            self._save_video(predictions, fps)
        except Exception as e:
            self.log.error(f"Animation failed: {str(e)}")
            raise

    def _generate_animations(self, source_image: np.ndarray, driving_video: list[np.ndarray]) -> list[np.ndarray]:
        """Generate fomm frames with optional best frame processing."""
        if not self.find_best and self.best_frame is None:
            return AnimationService.make_animation(
                source_image,
                driving_video,
                self.generator,
                self.kp_detector,
                relative=self.relative,
                adapt_movement_scale=self.adapt_scale,
                cpu=self.cpu,
            )

        # Handle best frame processing
        i = (
            self.best_frame
            if self.best_frame is not None
            else find_best_frame(source_image, driving_video, cpu=self.cpu)
        )
        self.log.info(f"Using frame {i} as best match")

        # Split video at best frame
        driving_forward = driving_video[i:]
        driving_backward = driving_video[: i + 1][::-1]

        # Process both segments
        predictions_forward = AnimationService.make_animation(
            source_image,
            driving_forward,
            self.generator,
            self.kp_detector,
            relative=self.relative,
            adapt_movement_scale=self.adapt_scale,
            cpu=self.cpu,
        )

        predictions_backward = AnimationService.make_animation(
            source_image,
            driving_backward,
            self.generator,
            self.kp_detector,
            relative=self.relative,
            adapt_movement_scale=self.adapt_scale,
            cpu=self.cpu,
        )

        # Combine results (excluding duplicate middle frame)
        return predictions_backward[::-1] + predictions_forward[1:]

    def _save_video(self, frames: list[np.ndarray], fps: float) -> None:
        """Save frames to video file with proper encoding."""
        if not frames:
            raise ValueError("No frames to save")

        height, width = frames[0].shape[:2]
        fourcc = cv2.VideoWriter_fourcc(*"mp4v")

        out = None
        try:
            out = cv2.VideoWriter(self.result_video_path, fourcc, fps, (width, height))

            if not out.isOpened():
                raise IOError("Could not open video writer")

            for frame in frames:
                # Convert frame to proper format
                frame_bgr = cv2.cvtColor(img_as_ubyte(frame), cv2.COLOR_RGB2BGR)
                out.write(frame_bgr)

            self.log.info(f"Successfully saved video to {self.result_video_path}")
        finally:
            out.release() if "out" in locals() else None



# Файл "app\src\ml\services\visualization.py":

import matplotlib.pyplot as plt
import numpy as np
import torch.nn.functional as F
from skimage.draw import disk as circle


class VisualizationService:
    def __init__(self, kp_size: int = 5, draw_border: bool = False, colormap: str = "gist_rainbow") -> None:
        self.kp_size = kp_size
        self.draw_border = draw_border
        self.colormap = plt.get_cmap(colormap)

    def draw_image_with_kp(self, image, kp_array) -> np.ndarray:
        image = np.copy(image)
        spatial_size = np.array(image.shape[:2][::-1])[np.newaxis]
        kp_array = spatial_size * (kp_array + 1) / 2
        num_kp = kp_array.shape[0]
        for kp_ind, kp in enumerate(kp_array):
            rr, cc = circle(kp[1], kp[0], self.kp_size, shape=image.shape[:2])
            image[rr, cc] = np.array(self.colormap(kp_ind / num_kp))[:3]
        return image

    def create_image_column_with_kp(self, images, kp) -> np.ndarray:
        image_array = np.array([self.draw_image_with_kp(v, k) for v, k in zip(images, kp)])
        return self.create_image_column(image_array)

    def create_image_column(self, images) -> np.ndarray:
        if self.draw_border:
            images = np.copy(images)
            images[:, :, [0, -1]] = (1, 1, 1)
            images[:, :, [0, -1]] = (1, 1, 1)
        return np.concatenate(list(images), axis=0)

    def create_image_grid(self, *args) -> np.ndarray:
        out = []
        for arg in args:
            if type(arg) == tuple:
                out.append(self.create_image_column_with_kp(arg[0], arg[1]))
            else:
                out.append(self.create_image_column(arg))
        return np.concatenate(out, axis=1)

    def visualize(self, driving, source, out) -> np.ndarray:
        images = []

        # Source image with keypoints
        source = source.data.cpu()
        kp_source = out["kp_source"]["value"].data.cpu().numpy()
        source = np.transpose(source, [0, 2, 3, 1])
        images.append((source, kp_source))

        # Equivariance visualization
        if "transformed_frame" in out:
            transformed = out["transformed_frame"].data.cpu().numpy()
            transformed = np.transpose(transformed, [0, 2, 3, 1])
            transformed_kp = out["transformed_kp"]["value"].data.cpu().numpy()
            images.append((transformed, transformed_kp))

        # Driving image with keypoints
        kp_driving = out["kp_driving"]["value"].data.cpu().numpy()
        driving = driving.data.cpu().numpy()
        driving = np.transpose(driving, [0, 2, 3, 1])
        images.append((driving, kp_driving))

        # Deformed image
        if "deformed" in out:
            deformed = out["deformed"].data.cpu().numpy()
            deformed = np.transpose(deformed, [0, 2, 3, 1])
            images.append(deformed)

        # Result with and without keypoints
        prediction = out["prediction"].data.cpu().numpy()
        prediction = np.transpose(prediction, [0, 2, 3, 1])
        if "kp_norm" in out:
            kp_norm = out["kp_norm"]["value"].data.cpu().numpy()
            images.append((prediction, kp_norm))
        images.append(prediction)

        # Occlusion map
        if "occlusion_map" in out:
            occlusion_map = out["occlusion_map"].data.cpu().repeat(1, 3, 1, 1)
            occlusion_map = F.interpolate(occlusion_map, size=source.shape[1:3]).numpy()
            occlusion_map = np.transpose(occlusion_map, [0, 2, 3, 1])
            images.append(occlusion_map)

        # Deformed images according to each individual transform
        if "sparse_deformed" in out:
            full_mask = []
            for i in range(out["sparse_deformed"].shape[1]):
                image = out["sparse_deformed"][:, i].data.cpu()
                image = F.interpolate(image, size=source.shape[1:3])
                mask = out["mask"][:, i : (i + 1)].data.cpu().repeat(1, 3, 1, 1)
                mask = F.interpolate(mask, size=source.shape[1:3])
                image = np.transpose(image.numpy(), (0, 2, 3, 1))
                mask = np.transpose(mask.numpy(), (0, 2, 3, 1))

                if i != 0:
                    color = np.array(self.colormap((i - 1) / (out["sparse_deformed"].shape[1] - 1)))[:3]
                else:
                    color = np.array((0, 0, 0))

                color = color.reshape((1, 1, 1, 3))

                images.append(image)
                if i != 0:
                    images.append(mask * color)
                else:
                    images.append(mask)

                full_mask.append(mask * color)

            images.append(sum(full_mask))

        image = self.create_image_grid(*images)
        image = (255 * image).astype(np.uint8)
        return image



# Файл "app\src\ml\services\__init__.py":





# Файл "app\src\server\config.py":

from enum import StrEnum

from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class APIModeEnum(StrEnum):
    LOCAL = "local"
    DEV = "dev"
    STAGE = "stage"
    PROD = "prod"


class LogLevelEnum(StrEnum):
    INFO = "info"
    DEBUG = "debug"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class APIConfig(BaseSettings):
    ML_ENGINE_KEY: str = Field(..., alias="ML_ENGINE_KEY")
    MODE: APIModeEnum = Field(..., alias="API_MODE")
    LOG_LEVEL: LogLevelEnum = Field(..., alias="LOG_LEVEL")

    model_config = SettingsConfigDict(env_file="../env/ml_engine.env")



# Файл "app\src\server\exceptions.py":

import logging
import traceback

from fastapi import Request, status
from pydantic import ValidationError
from src.server.config import APIConfig, APIModeEnum
from starlette.responses import JSONResponse

log = logging.getLogger(__name__)


class MLModelException(Exception):
    """Base exception for all errors related to ML Model"""


exception_handlers: dict[type[Exception], callable] = {
    MLModelException: lambda x: (status.HTTP_403_FORBIDDEN, "ML Model Error"),
    ValidationError: lambda x: (status.HTTP_422_UNPROCESSABLE_ENTITY, x.errors()),
}


def handle_exception(exc: Exception) -> tuple[str, int]:
    if handler := exception_handlers.get(type(exc)):
        status_code, message = handler(exc)
    else:
        status_code, message = status.HTTP_500_INTERNAL_SERVER_ERROR, "Internal server error"

    log.error(message, exc_info=True)

    if APIConfig().MODE != APIModeEnum.PROD:
        traceback_text = "".join(traceback.format_exception(type(exc), exc, exc.__traceback__))
        message = f"{message}: {str(exc)}\n{traceback_text}"

    return message, status_code


async def app_exception_handler(request: Request, exc: Exception):
    message, status_code = handle_exception(exc)
    return JSONResponse(status_code=status_code, content={"detail": message})



# Файл "app\src\server\routers.py":

import logging
import os
import shutil
from tempfile import NamedTemporaryFile
from typing import Iterator

from fastapi import APIRouter, File, HTTPException, UploadFile
from src.ml.services.video_animation import VideoAnimationService
from starlette.responses import StreamingResponse

router = APIRouter(prefix="/fomm", tags=["First Order Motion Model"])
log = logging.getLogger(__name__)


def stream_and_cleanup(filepath: str) -> Iterator[bytes]:
    try:
        with open(filepath, "rb") as f:
            yield from iter(lambda: f.read(8192), b"")
    finally:
        if os.path.exists(filepath):
            os.remove(filepath)


@router.post("/video")
async def animate_image_by_video(
    source_image: UploadFile = File(...),
    driving_video: UploadFile = File(...),
):
    try:
        log.info("Save temporary files")
        with NamedTemporaryFile(suffix=".png", delete=False) as temp_image_file, NamedTemporaryFile(
            suffix=".mp4", delete=False
        ) as temp_video_file:

            shutil.copyfileobj(source_image.file, temp_image_file)
            shutil.copyfileobj(driving_video.file, temp_video_file)
            temp_image_path = temp_image_file.name
            temp_video_path = temp_video_file.name

        output_video_path = temp_video_path.replace(".mp4", "_result.mp4")
        log.info(f"Path to final output video: {output_video_path}")

        service = VideoAnimationService(
            config_path="./data/configs/vox-256.yaml",
            checkpoint_path="./data/checkpoints/vox-cpk.pth.tar",
            source_image_path=temp_image_path,
            driving_video_path=temp_video_path,
            result_video_path=output_video_path,
            relative=False,
            adapt_scale=False,
            find_best=False,
            best_frame=None,
            cpu=True,
        )
        log.info("Run image animation service")
        service.run()

        return StreamingResponse(stream_and_cleanup(output_video_path), media_type="video/mp4")

    except Exception as e:
        log.error(f"Failed to process video: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to process video: {e}")

    finally:
        log.info("Remove temp files")
        for path in [locals().get("temp_image_path"), locals().get("temp_video_path")]:
            if path and os.path.exists(path):
                os.remove(path)



# Файл "app\src\server\__init__.py":

__version__ = "0.0.0"

from fastapi import Security
from fastapi.security import APIKeyHeader
from src.server.config import APIConfig
from src.server.exceptions import MLModelException

api_config = APIConfig()


async def validate_api_key(ml_engine_key: str = Security(APIKeyHeader(name="X-ML-Engine-Key", auto_error=False))):
    if ml_engine_key != api_config.ML_ENGINE_KEY:
        raise MLModelException("Invalid ML Engine Key")
    return ml_engine_key


